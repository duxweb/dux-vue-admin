{
  "version": 3,
  "sources": ["../../../../node_modules/@alova/shared/dist/vars.js", "../../../../node_modules/@alova/shared/dist/function.js"],
  "sourcesContent": ["/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nconst undefStr = 'undefined';\n// 以下为减少编译代码量而添加的统一处理函数或变量\nconst PromiseCls = Promise;\nconst promiseResolve = (value) => PromiseCls.resolve(value);\nconst promiseReject = (value) => PromiseCls.reject(value);\nconst ObjectCls = Object;\nconst RegExpCls = RegExp;\nconst undefinedValue = undefined;\nconst nullValue = null;\nconst trueValue = true;\nconst falseValue = false;\nconst promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);\nconst promiseCatch = (promise, onrejected) => promise.catch(onrejected);\nconst promiseFinally = (promise, onfinally) => promise.finally(onfinally);\nconst JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);\nconst JSONParse = (value) => JSON.parse(value);\nconst setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);\nconst clearTimeoutTimer = (timer) => clearTimeout(timer);\nconst objectKeys = (obj) => ObjectCls.keys(obj);\nconst objectValues = (obj) => ObjectCls.values(obj);\nconst forEach = (ary, fn) => ary.forEach(fn);\nconst pushItem = (ary, ...item) => ary.push(...item);\nconst mapItem = (ary, callbackfn) => ary.map(callbackfn);\nconst filterItem = (ary, predicate) => ary.filter(predicate);\nconst shift = (ary) => ary.shift();\nconst slice = (ary, start, end) => ary.slice(start, end);\nconst splice = (ary, start, deleteCount = 0, ...items) => ary.splice(start, deleteCount, ...items);\nconst len = (data) => data.length;\nconst isArray = (arg) => Array.isArray(arg);\nconst deleteAttr = (arg, attr) => delete arg[attr];\nconst typeOf = (arg) => typeof arg;\nconst regexpTest = (reg, str) => reg.test(str);\nconst includes = (ary, target) => ary.includes(target);\nconst valueObject = (value, writable = falseValue) => ({ value, writable });\nconst defineProperty = (o, key, value, isDescriptor = falseValue) => ObjectCls.defineProperty(o, key, isDescriptor ? value : valueObject(value, falseValue));\n// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断\n// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用\n// 因此使用服务端独有的 process.cwd 函数作为判断依据\nconst defaultIsSSR = typeof window === undefStr &&\n    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);\nconst isSSR = defaultIsSSR;\n/** cache mode */\n// only cache in memory, it's default option\nconst MEMORY = 'memory';\n// persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.\nconst STORAGE_RESTORE = 'restore';\n\nexport { JSONParse, JSONStringify, MEMORY, ObjectCls, PromiseCls, RegExpCls, STORAGE_RESTORE, clearTimeoutTimer, defaultIsSSR, defineProperty, deleteAttr, falseValue, filterItem, forEach, includes, isArray, isSSR, len, mapItem, nullValue, objectKeys, objectValues, promiseCatch, promiseFinally, promiseReject, promiseResolve, promiseThen, pushItem, regexpTest, setTimeoutFn, shift, slice, splice, trueValue, typeOf, undefinedValue, valueObject };\n", "/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nclass FrameworkReadableState {\n    constructor(state, key, dehydrate, exportState) {\n        this.s = state;\n        this.k = key;\n        this.$dhy = dehydrate;\n        this.$exp = exportState;\n    }\n    get v() {\n        return this.$dhy(this.s);\n    }\n    get e() {\n        return this.$exp(this.s);\n    }\n}\nclass FrameworkState extends FrameworkReadableState {\n    constructor(state, key, dehydrate, exportState, update) {\n        super(state, key, dehydrate, exportState);\n        this.$upd = update;\n    }\n    set v(newValue) {\n        this.$upd(this.s, newValue);\n    }\n    get v() {\n        return super.v;\n    }\n}\n\nconst undefStr = 'undefined';\n// 以下为减少编译代码量而添加的统一处理函数或变量\nconst PromiseCls = Promise;\nconst ObjectCls = Object;\nconst undefinedValue = undefined;\nconst nullValue = null;\nconst trueValue = true;\nconst falseValue = false;\nconst promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);\nconst JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);\nconst setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);\nconst objectKeys = (obj) => ObjectCls.keys(obj);\nconst forEach = (ary, fn) => ary.forEach(fn);\nconst pushItem = (ary, ...item) => ary.push(...item);\nconst mapItem = (ary, callbackfn) => ary.map(callbackfn);\nconst shift = (ary) => ary.shift();\nconst len = (data) => data.length;\nconst typeOf = (arg) => typeof arg;\nconst includes = (ary, target) => ary.includes(target);\n// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断\n// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用\n// 因此使用服务端独有的 process.cwd 函数作为判断依据\ntypeof window === undefStr &&\n    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);\n/** cache mode */\n// only cache in memory, it's default option\nconst MEMORY = 'memory';\n// persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.\nconst STORAGE_RESTORE = 'restore';\n\n/**\n * 空函数，做兼容处理\n */\nconst noop = () => { };\n/**\n * 返回参数自身的函数，做兼容处理用\n * 由于部分系统将self作为了保留字，故使用$self来区分\n * @param arg 任意参数\n * @returns 返回参数本身\n */\nconst $self = (arg) => arg;\n/**\n * 判断参数是否为函数\n * @param fn 任意参数\n * @returns 该参数是否为函数\n */\nconst isFn = (arg) => typeOf(arg) === 'function';\n/**\n * 判断参数是否为数字\n * @param arg 任意参数\n * @returns 该参数是否为数字\n */\nconst isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);\n/**\n * 判断参数是否为字符串\n * @param arg 任意参数\n * @returns 该参数是否为字符串\n */\nconst isString = (arg) => typeOf(arg) === 'string';\n/**\n * 判断参数是否为对象\n * @param arg 任意参数\n * @returns 该参数是否为对象\n */\nconst isObject = (arg) => arg !== nullValue && typeOf(arg) === 'object';\n/**\n * 全局的toString\n * @param arg 任意参数\n * @returns 字符串化的参数\n */\nconst globalToString = (arg) => ObjectCls.prototype.toString.call(arg);\n/**\n * 判断是否为普通对象\n * @param arg 任意参数\n * @returns 判断结果\n */\nconst isPlainObject = (arg) => globalToString(arg) === '[object Object]';\n/**\n * 判断是否为某个类的实例\n * @param arg 任意参数\n * @returns 判断结果\n */\nconst instanceOf = (arg, cls) => arg instanceof cls;\n/**\n * 统一的时间戳获取函数\n * @returns 时间戳\n */\nconst getTime = (date) => (date ? date.getTime() : Date.now());\n/**\n * 通过method实例获取alova实例\n * @returns alova实例\n */\nconst getContext = (methodInstance) => methodInstance.context;\n/**\n * 获取method实例配置数据\n * @returns 配置对象\n */\nconst getConfig = (methodInstance) => methodInstance.config;\n/**\n * 获取alova配置数据\n * @returns alova配置对象\n */\nconst getContextOptions = (alovaInstance) => alovaInstance.options;\n/**\n * 通过method实例获取alova配置数据\n * @returns alova配置对象\n */\nconst getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));\n/**\n * 获取请求方式的key值\n * @returns 此请求方式的key值\n */\nconst key = (methodInstance) => {\n    const { params, headers } = getConfig(methodInstance);\n    return JSONStringify([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);\n};\n/**\n * 创建uuid简易版\n * @returns uuid\n */\nconst uuid = () => {\n    const timestamp = new Date().getTime();\n    return Math.floor(Math.random() * timestamp).toString(36);\n};\n/**\n * 获取method实例的key值\n * @param methodInstance method实例\n * @returns 此method实例的key值\n */\nconst getMethodInternalKey = (methodInstance) => methodInstance.key;\n/**\n * 获取请求方法对象\n * @param methodHandler 请求方法句柄\n * @param args 方法调用参数\n * @returns 请求方法对象\n */\nconst getHandlerMethod = (methodHandler, assert, args = []) => {\n    const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;\n    assert(!!methodInstance.key, 'hook handler must be a method instance or a function that returns method instance');\n    return methodInstance;\n};\n/**\n * 是否为特殊数据\n * @param data 提交数据\n * @returns 判断结果\n */\nconst isSpecialRequestBody = (data) => {\n    const dataTypeString = globalToString(data);\n    return (/^\\[object (Blob|FormData|ReadableStream|URLSearchParams)\\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));\n};\nconst objAssign = (target, ...sources) => ObjectCls.assign(target, ...sources);\n/**\n * 排除一个数据集合中指定的属性，并返回新的数据集合\n * @param obj 数据集合\n * @param keys 排除的key\n * @returns 新的数据集合\n */\nconst omit = (obj, ...keys) => {\n    const result = {};\n    for (const key in obj) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n};\n/**\n * the same as `Promise.withResolvers`\n * @returns promise with resolvers.\n */\nfunction usePromise() {\n    let retResolve;\n    let retReject;\n    const promise = new Promise((resolve, reject) => {\n        retResolve = resolve;\n        retReject = reject;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: retResolve, reject: retReject };\n}\n/**\n * 获取缓存的配置参数，固定返回{ e: function, c: any, f: any, m: number, s: boolean, t: string }格式的对象\n * e为expire缩写，它返回缓存失效时间点（时间戳），单位为毫秒\n * c为controlled，表示是否为受控缓存\n * f为cacheFor原始值，用于在c为true时调用获取缓存数据\n * m为mode缩写，存储模式\n * s为storage缩写，是否存储到本地\n * t为tag缩写，持久化存储标签\n * @param methodInstance method实例\n * @returns 统一的缓存参数对象\n */\nconst getLocalCacheConfigParam = (methodInstance) => {\n    const { cacheFor } = getConfig(methodInstance);\n    const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue);\n    let cacheMode = MEMORY;\n    let expire = () => 0;\n    let store = falseValue;\n    let tag = undefinedValue;\n    const controlled = isFn(cacheFor);\n    if (!controlled) {\n        let expireColumn = cacheFor;\n        if (isPlainObject(cacheFor)) {\n            const { mode = MEMORY, expire, tag: configTag } = cacheFor || {};\n            cacheMode = mode;\n            store = mode === STORAGE_RESTORE;\n            tag = configTag ? configTag.toString() : undefinedValue;\n            expireColumn = expire;\n        }\n        expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);\n    }\n    return {\n        f: cacheFor,\n        c: controlled,\n        e: expire,\n        m: cacheMode,\n        s: store,\n        t: tag\n    };\n};\n/**\n * 创建类实例\n * @param Cls 构造函数\n * @param args 构造函数参数\n * @returns 类实例\n */\nconst newInstance = (Cls, ...args) => new Cls(...args);\n/**\n * 统一配置\n * @param 数据\n * @returns 统一的配置\n */\nconst sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;\nconst sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue, nullValue].includes(arg) ? defaultFn : noop;\n/**\n * 创建同步多次调用只在异步执行一次的执行器\n */\nconst createSyncOnceRunner = (delay = 0) => {\n    let timer = undefinedValue;\n    // 执行多次调用此函数将异步执行一次\n    return (fn) => {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeoutFn(fn, delay);\n    };\n};\n/**\n * 创建异步函数队列，异步函数将串行执行\n * @returns 队列添加函数\n */\nconst createAsyncQueue = (catchError = falseValue) => {\n    const queue = [];\n    let completedHandler = undefinedValue;\n    let executing = false;\n    const executeQueue = async () => {\n        executing = true;\n        while (len(queue) > 0) {\n            const asyncFunc = shift(queue);\n            if (asyncFunc) {\n                await asyncFunc();\n            }\n        }\n        completedHandler && completedHandler();\n        executing = false;\n    };\n    const addQueue = (asyncFunc) => newInstance((PromiseCls), (resolve, reject) => {\n        const wrappedFunc = () => promiseThen(asyncFunc(), resolve, err => {\n            catchError ? resolve(undefinedValue) : reject(err);\n        });\n        pushItem(queue, wrappedFunc);\n        if (!executing) {\n            executeQueue();\n        }\n    });\n    const onComplete = (fn) => {\n        completedHandler = fn;\n    };\n    return {\n        addQueue,\n        onComplete\n    };\n};\n/**\n * 深层遍历目标对象\n * @param target 目标对象\n * @param callback 遍历回调\n * @param preorder 是否前序遍历，默认为true\n * @param key 当前遍历的key\n * @param parent 当前遍历的父节点\n */\nconst walkObject = (target, callback, preorder = trueValue, key, parent) => {\n    const callCallback = () => {\n        if (parent && key) {\n            target = callback(target, key, parent);\n            if (target !== parent[key]) {\n                parent[key] = target;\n            }\n        }\n    };\n    // 前序遍历\n    preorder && callCallback();\n    if (isObject(target)) {\n        for (const i in target) {\n            if (!instanceOf(target, String)) {\n                walkObject(target[i], callback, preorder, i, target);\n            }\n        }\n    }\n    // 后序遍历\n    !preorder && callCallback();\n    return target;\n};\n/**\n * create simple and unified, framework-independent states creators and handlers.\n * @param statesHook states hook from `promiseStatesHook` function of alova\n * @param referingObject refering object exported from `promiseStatesHook` function\n * @returns simple and unified states creators and handlers\n */\nfunction statesHookHelper(statesHook, referingObject = { trackedKeys: {}, bindError: falseValue }) {\n    const ref = (initialValue) => (statesHook.ref ? statesHook.ref(initialValue) : { current: initialValue });\n    referingObject = ref(referingObject).current;\n    const exportState = (state) => (statesHook.export || $self)(state, referingObject);\n    const memorize = (fn) => {\n        if (!isFn(statesHook.memorize)) {\n            return fn;\n        }\n        const memorizedFn = statesHook.memorize(fn);\n        memorizedFn.memorized = true;\n        return memorizedFn;\n    };\n    const { dehydrate } = statesHook;\n    // For performance reasons, only value is different, and the key is tracked can be updated.\n    const update = (newValue, state, key) => newValue !== dehydrate(state, key, referingObject) &&\n        referingObject.trackedKeys[key] &&\n        statesHook.update(newValue, state, key, referingObject);\n    const mapDeps = (deps) => mapItem(deps, item => (instanceOf(item, FrameworkReadableState) ? item.e : item));\n    const createdStateList = [];\n    // key of deps on computed\n    const depKeys = {};\n    return {\n        create: (initialValue, key) => {\n            pushItem(createdStateList, key); // record the keys of created states.\n            return newInstance((FrameworkState), statesHook.create(initialValue, key, referingObject), key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key));\n        },\n        computed: (getter, depList, key) => {\n            // Collect all dependencies in computed\n            forEach(depList, dep => {\n                if (dep.k) {\n                    depKeys[dep.k] = true;\n                }\n            });\n            return newInstance((FrameworkReadableState), statesHook.computed(getter, mapDeps(depList), key, referingObject), key, state => dehydrate(state, key, referingObject), exportState);\n        },\n        effectRequest: (effectRequestParams) => statesHook.effectRequest(effectRequestParams, referingObject),\n        ref,\n        watch: (source, callback) => statesHook.watch(mapDeps(source), callback, referingObject),\n        onMounted: (callback) => statesHook.onMounted(callback, referingObject),\n        onUnmounted: (callback) => statesHook.onUnmounted(callback, referingObject),\n        /**\n         * refering object that sharing some value with this object.\n         */\n        __referingObj: referingObject,\n        /**\n         * expose provider for specified use hook.\n         * @param object object that contains state proxy, framework state, operating function and event binder.\n         * @returns provider component.\n         */\n        exposeProvider: (object) => {\n            const provider = {};\n            const originalStatesMap = {};\n            for (const key in object) {\n                const value = object[key];\n                const isValueFunction = isFn(value);\n                // if it's a memorized function, don't memorize it any more, add it to provider directly.\n                // if it's start with `on`, it indicates it is an event binder, we should define a new function which return provider object.\n                // if it's a common function, add it to provider with memorize mode.\n                if (isValueFunction) {\n                    provider[key] = key.startsWith('on')\n                        ? (...args) => {\n                            value(...args);\n                            // eslint-disable-next-line\n                            return completedProvider;\n                        }\n                        : value.memorized\n                            ? value\n                            : memorize(value);\n                }\n                else {\n                    const isFrameworkState = instanceOf(value, FrameworkReadableState);\n                    if (isFrameworkState) {\n                        originalStatesMap[key] = value.s;\n                    }\n                    // otherwise, it's a state proxy or framework state, add it to provider with getter mode.\n                    ObjectCls.defineProperty(provider, key, {\n                        get: () => {\n                            // record the key that is being tracked.\n                            referingObject.trackedKeys[key] = trueValue;\n                            return isFrameworkState ? value.e : value;\n                        },\n                        // set need to set an function,\n                        // otherwise it will throw `TypeError: Cannot set property __referingObj of #<Object> which has only a getter` when setting value\n                        set: noop,\n                        enumerable: trueValue,\n                        configurable: trueValue\n                    });\n                }\n            }\n            const { update: nestedHookUpdate, __proxyState: nestedProxyState } = provider;\n            // reset the tracked keys and bingError flag, so that the nest hook providers can be initialized.\n            // Always track the dependencies in computed\n            referingObject.trackedKeys = {\n                ...depKeys\n            };\n            referingObject.bindError = falseValue;\n            const extraProvider = {\n                // expose referingObject automatically.\n                __referingObj: referingObject,\n                // the new updating function that can update the new states and nested hook states.\n                update: memorize((newStates) => {\n                    objectKeys(newStates).forEach(key => {\n                        if (includes(createdStateList, key)) {\n                            update(newStates[key], originalStatesMap[key], key);\n                        }\n                        else if (key in provider && isFn(nestedHookUpdate)) {\n                            nestedHookUpdate({\n                                [key]: newStates[key]\n                            });\n                        }\n                    });\n                }),\n                __proxyState: memorize((key) => {\n                    if (includes(createdStateList, key) && instanceOf(object[key], FrameworkReadableState)) {\n                        // need to tag the key that is being tracked so that it can be updated with `state.v = xxx`.\n                        referingObject.trackedKeys[key] = trueValue;\n                        return object[key];\n                    }\n                    return nestedProxyState(key);\n                })\n            };\n            const completedProvider = objAssign(provider, extraProvider);\n            return completedProvider;\n        },\n        /**\n         * transform state proxies to object.\n         * @param states proxy array of framework states\n         * @param filterKey filter key of state proxy\n         * @returns an object that contains the states of target form\n         */\n        objectify: (states, filterKey) => states.reduce((result, item) => {\n            result[item.k] = filterKey ? item[filterKey] : item;\n            return result;\n        }, {}),\n        transformState2Proxy: (state, key) => newInstance((FrameworkState), state, key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key))\n    };\n}\nconst cacheKeyPrefix = '$a.';\n/**\n * build common cache key.\n */\nconst buildNamespacedCacheKey = (namespace, key) => cacheKeyPrefix + namespace + key;\n/**\n * 根据避让策略和重试次数计算重试延迟时间\n * @param backoff 避让参数\n * @param retryTimes 重试次数\n * @returns 重试延迟时间\n */\nconst delayWithBackoff = (backoff, retryTimes) => {\n    let { startQuiver, endQuiver } = backoff;\n    const { delay, multiplier = 1 } = backoff;\n    let retryDelayFinally = (delay || 0) * multiplier ** (retryTimes - 1);\n    // 如果startQuiver或endQuiver有值，则需要增加指定范围的随机抖动值\n    if (startQuiver || endQuiver) {\n        startQuiver = startQuiver || 0;\n        endQuiver = endQuiver || 1;\n        retryDelayFinally +=\n            retryDelayFinally * startQuiver + Math.random() * retryDelayFinally * (endQuiver - startQuiver);\n        retryDelayFinally = Math.floor(retryDelayFinally); // 取整数延迟\n    }\n    return retryDelayFinally;\n};\n\nexport { $self, buildNamespacedCacheKey, createAsyncQueue, createSyncOnceRunner, delayWithBackoff, getConfig, getContext, getContextOptions, getHandlerMethod, getLocalCacheConfigParam, getMethodInternalKey, getOptions, getTime, globalToString, instanceOf, isFn, isNumber, isObject, isPlainObject, isSpecialRequestBody, isString, key, newInstance, noop, objAssign, omit, sloughConfig, sloughFunction, statesHookHelper, usePromise, uuid, walkObject };\n"],
  "mappings": ";AAOA,IAAM,WAAW;AAEjB,IAAM,aAAa;AACnB,IAAM,iBAAiB,CAAC,UAAU,WAAW,QAAQ,KAAK;AAC1D,IAAM,gBAAgB,CAAC,UAAU,WAAW,OAAO,KAAK;AACxD,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,iBAAiB;AACvB,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,cAAc,CAAC,SAAS,aAAa,eAAe,QAAQ,KAAK,aAAa,UAAU;AAC9F,IAAM,eAAe,CAAC,SAAS,eAAe,QAAQ,MAAM,UAAU;AACtE,IAAM,iBAAiB,CAAC,SAAS,cAAc,QAAQ,QAAQ,SAAS;AACxE,IAAM,gBAAgB,CAAC,OAAO,UAAU,UAAU,KAAK,UAAU,OAAO,UAAU,KAAK;AACvF,IAAM,YAAY,CAAC,UAAU,KAAK,MAAM,KAAK;AAC7C,IAAM,eAAe,CAAC,IAAI,QAAQ,MAAM,WAAW,IAAI,KAAK;AAC5D,IAAM,oBAAoB,CAAC,UAAU,aAAa,KAAK;AACvD,IAAM,aAAa,CAAC,QAAQ,UAAU,KAAK,GAAG;AAC9C,IAAM,eAAe,CAAC,QAAQ,UAAU,OAAO,GAAG;AAClD,IAAM,UAAU,CAAC,KAAK,OAAO,IAAI,QAAQ,EAAE;AAC3C,IAAM,WAAW,CAAC,QAAQ,SAAS,IAAI,KAAK,GAAG,IAAI;AACnD,IAAM,UAAU,CAAC,KAAK,eAAe,IAAI,IAAI,UAAU;AACvD,IAAM,aAAa,CAAC,KAAK,cAAc,IAAI,OAAO,SAAS;AAC3D,IAAM,QAAQ,CAAC,QAAQ,IAAI,MAAM;AAEjC,IAAM,SAAS,CAAC,KAAK,OAAO,cAAc,MAAM,UAAU,IAAI,OAAO,OAAO,aAAa,GAAG,KAAK;AACjG,IAAM,MAAM,CAAC,SAAS,KAAK;AAC3B,IAAM,UAAU,CAAC,QAAQ,MAAM,QAAQ,GAAG;AAC1C,IAAM,aAAa,CAAC,KAAK,SAAS,OAAO,IAAI,IAAI;AAEjD,IAAM,aAAa,CAAC,KAAK,QAAQ,IAAI,KAAK,GAAG;AAC7C,IAAM,WAAW,CAAC,KAAK,WAAW,IAAI,SAAS,MAAM;AACrD,IAAM,cAAc,CAAC,OAAO,WAAW,gBAAgB,EAAE,OAAO,SAAS;AACzE,IAAM,iBAAiB,CAAC,GAAGA,MAAK,OAAO,eAAe,eAAe,UAAU,eAAe,GAAGA,MAAK,eAAe,QAAQ,YAAY,OAAO,UAAU,CAAC;AAI3J,IAAM,eAAe,OAAO,WAAW,aAClC,OAAO,YAAY,WAAW,OAAO,QAAQ,QAAQ,aAAa,OAAO,SAAS;AAIvF,IAAM,SAAS;AAEf,IAAM,kBAAkB;;;AC7CxB,IAAM,yBAAN,MAA6B;AAAA,EACzB,YAAY,OAAOC,MAAK,WAAW,aAAa;AAC5C,SAAK,IAAI;AACT,SAAK,IAAIA;AACT,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,IAAI,IAAI;AACJ,WAAO,KAAK,KAAK,KAAK,CAAC;AAAA,EAC3B;AAAA,EACA,IAAI,IAAI;AACJ,WAAO,KAAK,KAAK,KAAK,CAAC;AAAA,EAC3B;AACJ;AACA,IAAM,iBAAN,cAA6B,uBAAuB;AAAA,EAChD,YAAY,OAAOA,MAAK,WAAW,aAAa,QAAQ;AACpD,UAAM,OAAOA,MAAK,WAAW,WAAW;AACxC,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,IAAI,EAAE,UAAU;AACZ,SAAK,KAAK,KAAK,GAAG,QAAQ;AAAA,EAC9B;AAAA,EACA,IAAI,IAAI;AACJ,WAAO,MAAM;AAAA,EACjB;AACJ;AAEA,IAAMC,YAAW;AAEjB,IAAMC,cAAa;AACnB,IAAMC,aAAY;AAClB,IAAMC,kBAAiB;AACvB,IAAMC,aAAY;AAClB,IAAMC,aAAY;AAClB,IAAMC,cAAa;AACnB,IAAMC,eAAc,CAAC,SAAS,aAAa,eAAe,QAAQ,KAAK,aAAa,UAAU;AAC9F,IAAMC,iBAAgB,CAAC,OAAO,UAAU,UAAU,KAAK,UAAU,OAAO,UAAU,KAAK;AACvF,IAAMC,gBAAe,CAAC,IAAI,QAAQ,MAAM,WAAW,IAAI,KAAK;AAC5D,IAAMC,cAAa,CAAC,QAAQR,WAAU,KAAK,GAAG;AAC9C,IAAMS,WAAU,CAAC,KAAK,OAAO,IAAI,QAAQ,EAAE;AAC3C,IAAMC,YAAW,CAAC,QAAQ,SAAS,IAAI,KAAK,GAAG,IAAI;AACnD,IAAMC,WAAU,CAAC,KAAK,eAAe,IAAI,IAAI,UAAU;AACvD,IAAMC,SAAQ,CAAC,QAAQ,IAAI,MAAM;AACjC,IAAMC,OAAM,CAAC,SAAS,KAAK;AAC3B,IAAM,SAAS,CAAC,QAAQ,OAAO;AAC/B,IAAMC,YAAW,CAAC,KAAK,WAAW,IAAI,SAAS,MAAM;AAIrD,OAAO,WAAWhB,cACb,OAAO,YAAYA,YAAW,OAAO,QAAQ,QAAQ,aAAa,OAAO,SAASA;AAGvF,IAAMiB,UAAS;AAEf,IAAMC,mBAAkB;AAKxB,IAAM,OAAO,MAAM;AAAE;AAOrB,IAAM,QAAQ,CAAC,QAAQ;AAMvB,IAAM,OAAO,CAAC,QAAQ,OAAO,GAAG,MAAM;AAMtC,IAAM,WAAW,CAAC,QAAQ,OAAO,GAAG,MAAM,YAAY,CAAC,OAAO,MAAM,GAAG;AAMvE,IAAM,WAAW,CAAC,QAAQ,OAAO,GAAG,MAAM;AAM1C,IAAM,WAAW,CAAC,QAAQ,QAAQd,cAAa,OAAO,GAAG,MAAM;AAM/D,IAAM,iBAAiB,CAAC,QAAQF,WAAU,UAAU,SAAS,KAAK,GAAG;AAMrE,IAAM,gBAAgB,CAAC,QAAQ,eAAe,GAAG,MAAM;AAMvD,IAAM,aAAa,CAAC,KAAK,QAAQ,eAAe;AAKhD,IAAM,UAAU,CAAC,SAAU,OAAO,KAAK,QAAQ,IAAI,KAAK,IAAI;AAK5D,IAAM,aAAa,CAAC,mBAAmB,eAAe;AAKtD,IAAM,YAAY,CAAC,mBAAmB,eAAe;AAKrD,IAAM,oBAAoB,CAAC,kBAAkB,cAAc;AAK3D,IAAM,aAAa,CAAC,mBAAmB,kBAAkB,WAAW,cAAc,CAAC;AAKnF,IAAM,MAAM,CAAC,mBAAmB;AAC5B,QAAM,EAAE,QAAQ,QAAQ,IAAI,UAAU,cAAc;AACpD,SAAOM,eAAc,CAAC,eAAe,MAAM,eAAe,KAAK,QAAQ,eAAe,MAAM,OAAO,CAAC;AACxG;AAKA,IAAM,OAAO,MAAM;AACf,QAAM,aAAY,oBAAI,KAAK,GAAE,QAAQ;AACrC,SAAO,KAAK,MAAM,KAAK,OAAO,IAAI,SAAS,EAAE,SAAS,EAAE;AAC5D;AAMA,IAAM,uBAAuB,CAAC,mBAAmB,eAAe;AAOhE,IAAM,mBAAmB,CAAC,eAAe,QAAQ,OAAO,CAAC,MAAM;AAC3D,QAAM,iBAAiB,KAAK,aAAa,IAAI,cAAc,GAAG,IAAI,IAAI;AACtE,SAAO,CAAC,CAAC,eAAe,KAAK,mFAAmF;AAChH,SAAO;AACX;AAMA,IAAM,uBAAuB,CAAC,SAAS;AACnC,QAAM,iBAAiB,eAAe,IAAI;AAC1C,SAAQ,+DAA+D,KAAK,cAAc,KAAK,WAAW,MAAM,WAAW;AAC/H;AACA,IAAM,YAAY,CAAC,WAAW,YAAYN,WAAU,OAAO,QAAQ,GAAG,OAAO;AAO7E,IAAM,OAAO,CAAC,QAAQ,SAAS;AAC3B,QAAM,SAAS,CAAC;AAChB,aAAWH,QAAO,KAAK;AACnB,QAAI,CAAC,KAAK,SAASA,IAAG,GAAG;AACrB,aAAOA,IAAG,IAAI,IAAIA,IAAG;AAAA,IACzB;AAAA,EACJ;AACA,SAAO;AACX;AAKA,SAAS,aAAa;AAClB,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC7C,iBAAa;AACb,gBAAY;AAAA,EAChB,CAAC;AAED,SAAO,EAAE,SAAS,SAAS,YAAY,QAAQ,UAAU;AAC7D;AAYA,IAAM,2BAA2B,CAAC,mBAAmB;AACjD,QAAM,EAAE,SAAS,IAAI,UAAU,cAAc;AAC7C,QAAM,mBAAmB,CAAC,gBAAgB,SAAS,WAAW,IAAI,QAAQ,IAAI,cAAc,QAAQ,eAAeI,eAAc;AACjI,MAAI,YAAYc;AAChB,MAAI,SAAS,MAAM;AACnB,MAAI,QAAQX;AACZ,MAAI,MAAMH;AACV,QAAM,aAAa,KAAK,QAAQ;AAChC,MAAI,CAAC,YAAY;AACb,QAAI,eAAe;AACnB,QAAI,cAAc,QAAQ,GAAG;AACzB,YAAM,EAAE,OAAOc,SAAQ,QAAAE,SAAQ,KAAK,UAAU,IAAI,YAAY,CAAC;AAC/D,kBAAY;AACZ,cAAQ,SAASD;AACjB,YAAM,YAAY,UAAU,SAAS,IAAIf;AACzC,qBAAegB;AAAA,IACnB;AACA,aAAS,CAAC,SAAS,iBAAiB,KAAK,YAAY,IAAI,aAAa,EAAE,QAAQ,gBAAgB,KAAK,CAAC,IAAI,YAAY;AAAA,EAC1H;AACA,SAAO;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACP;AACJ;AAOA,IAAM,cAAc,CAAC,QAAQ,SAAS,IAAI,IAAI,GAAG,IAAI;AAMrD,IAAM,eAAe,CAAC,QAAQ,OAAO,CAAC,MAAM,KAAK,MAAM,IAAI,OAAO,GAAG,IAAI,IAAI;AAC7E,IAAM,iBAAiB,CAAC,KAAK,cAAc,KAAK,GAAG,IAAI,MAAM,CAAC,CAACb,aAAYF,UAAS,EAAE,SAAS,GAAG,IAAI,YAAY;AAIlH,IAAM,uBAAuB,CAAC,QAAQ,MAAM;AACxC,MAAI,QAAQD;AAEZ,SAAO,CAAC,OAAO;AACX,QAAI,OAAO;AACP,mBAAa,KAAK;AAAA,IACtB;AACA,YAAQM,cAAa,IAAI,KAAK;AAAA,EAClC;AACJ;AAKA,IAAM,mBAAmB,CAAC,aAAaH,gBAAe;AAClD,QAAM,QAAQ,CAAC;AACf,MAAI,mBAAmBH;AACvB,MAAI,YAAY;AAChB,QAAM,eAAe,YAAY;AAC7B,gBAAY;AACZ,WAAOY,KAAI,KAAK,IAAI,GAAG;AACnB,YAAM,YAAYD,OAAM,KAAK;AAC7B,UAAI,WAAW;AACX,cAAM,UAAU;AAAA,MACpB;AAAA,IACJ;AACA,wBAAoB,iBAAiB;AACrC,gBAAY;AAAA,EAChB;AACA,QAAM,WAAW,CAAC,cAAc,YAAab,aAAa,CAAC,SAAS,WAAW;AAC3E,UAAM,cAAc,MAAMM,aAAY,UAAU,GAAG,SAAS,SAAO;AAC/D,mBAAa,QAAQJ,eAAc,IAAI,OAAO,GAAG;AAAA,IACrD,CAAC;AACD,IAAAS,UAAS,OAAO,WAAW;AAC3B,QAAI,CAAC,WAAW;AACZ,mBAAa;AAAA,IACjB;AAAA,EACJ,CAAC;AACD,QAAM,aAAa,CAAC,OAAO;AACvB,uBAAmB;AAAA,EACvB;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;AASA,IAAM,aAAa,CAAC,QAAQ,UAAU,WAAWP,YAAWN,MAAK,WAAW;AACxE,QAAM,eAAe,MAAM;AACvB,QAAI,UAAUA,MAAK;AACf,eAAS,SAAS,QAAQA,MAAK,MAAM;AACrC,UAAI,WAAW,OAAOA,IAAG,GAAG;AACxB,eAAOA,IAAG,IAAI;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAEA,cAAY,aAAa;AACzB,MAAI,SAAS,MAAM,GAAG;AAClB,eAAW,KAAK,QAAQ;AACpB,UAAI,CAAC,WAAW,QAAQ,MAAM,GAAG;AAC7B,mBAAW,OAAO,CAAC,GAAG,UAAU,UAAU,GAAG,MAAM;AAAA,MACvD;AAAA,IACJ;AAAA,EACJ;AAEA,GAAC,YAAY,aAAa;AAC1B,SAAO;AACX;AAOA,SAAS,iBAAiB,YAAY,iBAAiB,EAAE,aAAa,CAAC,GAAG,WAAWO,YAAW,GAAG;AAC/F,QAAM,MAAM,CAAC,iBAAkB,WAAW,MAAM,WAAW,IAAI,YAAY,IAAI,EAAE,SAAS,aAAa;AACvG,mBAAiB,IAAI,cAAc,EAAE;AACrC,QAAM,cAAc,CAAC,WAAW,WAAW,UAAU,OAAO,OAAO,cAAc;AACjF,QAAM,WAAW,CAAC,OAAO;AACrB,QAAI,CAAC,KAAK,WAAW,QAAQ,GAAG;AAC5B,aAAO;AAAA,IACX;AACA,UAAM,cAAc,WAAW,SAAS,EAAE;AAC1C,gBAAY,YAAY;AACxB,WAAO;AAAA,EACX;AACA,QAAM,EAAE,UAAU,IAAI;AAEtB,QAAM,SAAS,CAAC,UAAU,OAAOP,SAAQ,aAAa,UAAU,OAAOA,MAAK,cAAc,KACtF,eAAe,YAAYA,IAAG,KAC9B,WAAW,OAAO,UAAU,OAAOA,MAAK,cAAc;AAC1D,QAAM,UAAU,CAAC,SAASc,SAAQ,MAAM,UAAS,WAAW,MAAM,sBAAsB,IAAI,KAAK,IAAI,IAAK;AAC1G,QAAM,mBAAmB,CAAC;AAE1B,QAAM,UAAU,CAAC;AACjB,SAAO;AAAA,IACH,QAAQ,CAAC,cAAcd,SAAQ;AAC3B,MAAAa,UAAS,kBAAkBb,IAAG;AAC9B,aAAO,YAAa,gBAAiB,WAAW,OAAO,cAAcA,MAAK,cAAc,GAAGA,MAAK,WAAS,UAAU,OAAOA,MAAK,cAAc,GAAG,aAAa,CAAC,OAAO,aAAa,OAAO,UAAU,OAAOA,IAAG,CAAC;AAAA,IAClN;AAAA,IACA,UAAU,CAAC,QAAQ,SAASA,SAAQ;AAEhC,MAAAY,SAAQ,SAAS,SAAO;AACpB,YAAI,IAAI,GAAG;AACP,kBAAQ,IAAI,CAAC,IAAI;AAAA,QACrB;AAAA,MACJ,CAAC;AACD,aAAO,YAAa,wBAAyB,WAAW,SAAS,QAAQ,QAAQ,OAAO,GAAGZ,MAAK,cAAc,GAAGA,MAAK,WAAS,UAAU,OAAOA,MAAK,cAAc,GAAG,WAAW;AAAA,IACrL;AAAA,IACA,eAAe,CAAC,wBAAwB,WAAW,cAAc,qBAAqB,cAAc;AAAA,IACpG;AAAA,IACA,OAAO,CAAC,QAAQ,aAAa,WAAW,MAAM,QAAQ,MAAM,GAAG,UAAU,cAAc;AAAA,IACvF,WAAW,CAAC,aAAa,WAAW,UAAU,UAAU,cAAc;AAAA,IACtE,aAAa,CAAC,aAAa,WAAW,YAAY,UAAU,cAAc;AAAA;AAAA;AAAA;AAAA,IAI1E,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMf,gBAAgB,CAAC,WAAW;AACxB,YAAM,WAAW,CAAC;AAClB,YAAM,oBAAoB,CAAC;AAC3B,iBAAWA,QAAO,QAAQ;AACtB,cAAM,QAAQ,OAAOA,IAAG;AACxB,cAAM,kBAAkB,KAAK,KAAK;AAIlC,YAAI,iBAAiB;AACjB,mBAASA,IAAG,IAAIA,KAAI,WAAW,IAAI,IAC7B,IAAI,SAAS;AACX,kBAAM,GAAG,IAAI;AAEb,mBAAO;AAAA,UACX,IACE,MAAM,YACF,QACA,SAAS,KAAK;AAAA,QAC5B,OACK;AACD,gBAAM,mBAAmB,WAAW,OAAO,sBAAsB;AACjE,cAAI,kBAAkB;AAClB,8BAAkBA,IAAG,IAAI,MAAM;AAAA,UACnC;AAEA,UAAAG,WAAU,eAAe,UAAUH,MAAK;AAAA,YACpC,KAAK,MAAM;AAEP,6BAAe,YAAYA,IAAG,IAAIM;AAClC,qBAAO,mBAAmB,MAAM,IAAI;AAAA,YACxC;AAAA;AAAA;AAAA,YAGA,KAAK;AAAA,YACL,YAAYA;AAAA,YACZ,cAAcA;AAAA,UAClB,CAAC;AAAA,QACL;AAAA,MACJ;AACA,YAAM,EAAE,QAAQ,kBAAkB,cAAc,iBAAiB,IAAI;AAGrE,qBAAe,cAAc;AAAA,QACzB,GAAG;AAAA,MACP;AACA,qBAAe,YAAYC;AAC3B,YAAM,gBAAgB;AAAA;AAAA,QAElB,eAAe;AAAA;AAAA,QAEf,QAAQ,SAAS,CAAC,cAAc;AAC5B,UAAAI,YAAW,SAAS,EAAE,QAAQ,CAAAX,SAAO;AACjC,gBAAIiB,UAAS,kBAAkBjB,IAAG,GAAG;AACjC,qBAAO,UAAUA,IAAG,GAAG,kBAAkBA,IAAG,GAAGA,IAAG;AAAA,YACtD,WACSA,QAAO,YAAY,KAAK,gBAAgB,GAAG;AAChD,+BAAiB;AAAA,gBACb,CAACA,IAAG,GAAG,UAAUA,IAAG;AAAA,cACxB,CAAC;AAAA,YACL;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AAAA,QACD,cAAc,SAAS,CAACA,SAAQ;AAC5B,cAAIiB,UAAS,kBAAkBjB,IAAG,KAAK,WAAW,OAAOA,IAAG,GAAG,sBAAsB,GAAG;AAEpF,2BAAe,YAAYA,IAAG,IAAIM;AAClC,mBAAO,OAAON,IAAG;AAAA,UACrB;AACA,iBAAO,iBAAiBA,IAAG;AAAA,QAC/B,CAAC;AAAA,MACL;AACA,YAAM,oBAAoB,UAAU,UAAU,aAAa;AAC3D,aAAO;AAAA,IACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,WAAW,CAAC,QAAQ,cAAc,OAAO,OAAO,CAAC,QAAQ,SAAS;AAC9D,aAAO,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,IAAI;AAC/C,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,IACL,sBAAsB,CAAC,OAAOA,SAAQ,YAAa,gBAAiB,OAAOA,MAAK,CAAAqB,WAAS,UAAUA,QAAOrB,MAAK,cAAc,GAAG,aAAa,CAACqB,QAAO,aAAa,OAAO,UAAUA,QAAOrB,IAAG,CAAC;AAAA,EAClM;AACJ;AACA,IAAM,iBAAiB;AAIvB,IAAM,0BAA0B,CAAC,WAAWA,SAAQ,iBAAiB,YAAYA;AAOjF,IAAM,mBAAmB,CAAC,SAAS,eAAe;AAC9C,MAAI,EAAE,aAAa,UAAU,IAAI;AACjC,QAAM,EAAE,OAAO,aAAa,EAAE,IAAI;AAClC,MAAI,qBAAqB,SAAS,KAAK,eAAe,aAAa;AAEnE,MAAI,eAAe,WAAW;AAC1B,kBAAc,eAAe;AAC7B,gBAAY,aAAa;AACzB,yBACI,oBAAoB,cAAc,KAAK,OAAO,IAAI,qBAAqB,YAAY;AACvF,wBAAoB,KAAK,MAAM,iBAAiB;AAAA,EACpD;AACA,SAAO;AACX;",
  "names": ["key", "key", "undefStr", "PromiseCls", "ObjectCls", "undefinedValue", "nullValue", "trueValue", "falseValue", "promiseThen", "JSONStringify", "setTimeoutFn", "objectKeys", "forEach", "pushItem", "mapItem", "shift", "len", "includes", "MEMORY", "STORAGE_RESTORE", "expire", "state"]
}
