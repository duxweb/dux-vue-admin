{
  "version": 3,
  "sources": ["../../../../node_modules/alova/dist/clienthook/index.esm.js"],
  "sourcesContent": ["/**\n  * @alova/client 2.0.0 (https://alova.js.org)\n  * Document https://alova.js.org\n  * Copyright 2024 Scott hu. All Rights Reserved\n  * Licensed under MIT (https://github.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nimport { isPlainObject, instanceOf, newInstance, isFn, noop, $self, isNumber, getHandlerMethod as getHandlerMethod$1, getContext, getMethodInternalKey, omit, sloughConfig, buildNamespacedCacheKey, getTime, statesHookHelper, objAssign, isObject, walkObject, uuid as uuid$1, globalToString, delayWithBackoff, isString, getConfig, createAsyncQueue, getLocalCacheConfigParam, usePromise, getOptions } from '@alova/shared/function';\nimport { trueValue, falseValue, PromiseCls, pushItem as pushItem$1, len, forEach, undefinedValue, splice, clearTimeoutTimer, setTimeoutFn, nullValue, filterItem as filterItem$1, deleteAttr, promiseResolve, promiseThen, promiseCatch, isArray, objectKeys, ObjectCls, valueObject, defineProperty, includes, RegExpCls, regexpTest, shift, mapItem as mapItem$1, MEMORY, objectValues, promiseReject, promiseFinally } from '@alova/shared/vars';\nimport { createAssert, AlovaError } from '@alova/shared/assert';\nimport { Method, queryCache, promiseStatesHook, globalConfigMap, setCache, invalidateCache, hitCacheBySource } from 'alova';\n\nconst defaultVisitorMeta = {\n    authRole: null\n};\nconst defaultLoginMeta = {\n    authRole: 'login'\n};\nconst defaultLogoutMeta = {\n    authRole: 'logout'\n};\nconst defaultRefreshTokenMeta = {\n    authRole: 'refreshToken'\n};\nconst checkMethodRole = ({ meta }, metaMatches) => {\n    if (isPlainObject(meta)) {\n        for (const key in meta) {\n            if (Object.prototype.hasOwnProperty.call(meta, key)) {\n                const matchedMetaItem = metaMatches[key];\n                if (instanceOf(matchedMetaItem, RegExp) ? matchedMetaItem.test(meta[key]) : meta[key] === matchedMetaItem) {\n                    return trueValue;\n                }\n            }\n        }\n    }\n    return falseValue;\n};\nconst waitForTokenRefreshed = (method, waitingList) => newInstance(PromiseCls, resolve => {\n    pushItem$1(waitingList, {\n        method,\n        resolve\n    });\n});\nconst callHandlerIfMatchesMeta = (method, authorizationInterceptor, defaultMeta, response) => {\n    if (checkMethodRole(method, (authorizationInterceptor === null || authorizationInterceptor === void 0 ? void 0 : authorizationInterceptor.metaMatches) || defaultMeta)) {\n        const handler = isFn(authorizationInterceptor)\n            ? authorizationInterceptor\n            : isPlainObject(authorizationInterceptor) && isFn(authorizationInterceptor.handler)\n                ? authorizationInterceptor.handler\n                : noop;\n        return handler(response, method);\n    }\n};\nconst refreshTokenIfExpired = async (method, waitingList, updateRefreshStatus, handlerParams, refreshToken, tokenRefreshing) => {\n    // 当handleParams数量大于2时，说明是从响应中调用此函数的，此时需要重新请求原接口\n    const fromResponse = len(handlerParams) >= 2;\n    let isExpired = refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.isExpired(...handlerParams);\n    // 兼容处理同步函数和异步函数\n    if (instanceOf(isExpired, PromiseCls)) {\n        isExpired = await isExpired;\n    }\n    if (isExpired) {\n        try {\n            // 在响应中再次判断，防止请求多次刷新token，把在token刷新完成前发送的拦截并等待\n            let intentToRefreshToken = trueValue;\n            if (fromResponse && tokenRefreshing) {\n                intentToRefreshToken = falseValue; // 在此等待的请求表示token刷新中，当它们通过后不再需要再次刷新token了\n                await waitForTokenRefreshed(method, waitingList);\n            }\n            if (intentToRefreshToken) {\n                updateRefreshStatus(trueValue);\n                // 调用刷新token\n                await (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.handler(...handlerParams));\n                updateRefreshStatus(falseValue);\n                // 刷新token完成后，通知等待列表中的请求\n                forEach(waitingList, ({ resolve }) => resolve());\n            }\n            if (fromResponse) {\n                // 这里因为是重新请求原接口，与上一次请求叠加会导致重复调用transform，因此需要将transform置空去除一次调用\n                const { config } = method;\n                const methodTransformData = config.transform;\n                config.transform = undefinedValue;\n                const resentData = await method;\n                config.transform = methodTransformData;\n                return resentData;\n            }\n        }\n        finally {\n            updateRefreshStatus(falseValue);\n            splice(waitingList, 0, len(waitingList)); // 清空waitingList\n        }\n    }\n};\nconst onResponded2Record = (onRespondedHandlers) => {\n    let successHandler = undefinedValue;\n    let errorHandler = undefinedValue;\n    let onCompleteHandler = undefinedValue;\n    if (isFn(onRespondedHandlers)) {\n        successHandler = onRespondedHandlers;\n    }\n    else if (isPlainObject(onRespondedHandlers)) {\n        const { onSuccess, onError, onComplete } = onRespondedHandlers;\n        successHandler = isFn(onSuccess) ? onSuccess : successHandler;\n        errorHandler = isFn(onError) ? onError : errorHandler;\n        onCompleteHandler = isFn(onComplete) ? onComplete : onCompleteHandler;\n    }\n    return {\n        onSuccess: successHandler,\n        onError: errorHandler,\n        onComplete: onCompleteHandler\n    };\n};\n\n/**\n * 创建客户端的token认证拦截器\n * @param options 配置参数\n * @returns token认证拦截器函数\n */\nconst createClientTokenAuthentication = ({ visitorMeta, login, logout, refreshToken, assignToken = noop }) => {\n    let tokenRefreshing = falseValue;\n    const waitingList = [];\n    const onAuthRequired = onBeforeRequest => async (method) => {\n        const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);\n        const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);\n        // 被忽略的、登录、刷新token的请求不进行token认证\n        if (!isVisitorRole &&\n            !isLoginRole &&\n            !checkMethodRole(method, (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.metaMatches) || defaultRefreshTokenMeta)) {\n            // 如果正在刷新token，则等待刷新完成后再发请求\n            if (tokenRefreshing) {\n                await waitForTokenRefreshed(method, waitingList);\n            }\n            await refreshTokenIfExpired(method, waitingList, refreshing => {\n                tokenRefreshing = refreshing;\n            }, [method], refreshToken);\n        }\n        // 非访客和登录角色的请求会进入赋值token函数\n        if (!isVisitorRole && !isLoginRole) {\n            await assignToken(method);\n        }\n        return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);\n    };\n    const onResponseRefreshToken = originalResponded => {\n        const respondedRecord = onResponded2Record(originalResponded);\n        return {\n            ...respondedRecord,\n            onSuccess: async (response, method) => {\n                await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);\n                await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);\n                return (respondedRecord.onSuccess || $self)(response, method);\n            }\n        };\n    };\n    return {\n        waitingList,\n        onAuthRequired,\n        onResponseRefreshToken\n    };\n};\n/**\n * 创建服务端的token认证拦截器\n * @param options 配置参数\n * @returns token认证拦截器函数\n */\nconst createServerTokenAuthentication = ({ visitorMeta, login, logout, refreshTokenOnSuccess, refreshTokenOnError, assignToken = noop }) => {\n    let tokenRefreshing = falseValue;\n    const waitingList = [];\n    const onAuthRequired = onBeforeRequest => async (method) => {\n        const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);\n        const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);\n        // 被忽略的、登录、刷新token的请求不进行token认证\n        if (!isVisitorRole &&\n            !isLoginRole &&\n            !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta) &&\n            !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {\n            // 如果正在刷新token，则等待刷新完成后再发请求\n            if (tokenRefreshing) {\n                await waitForTokenRefreshed(method, waitingList);\n            }\n        }\n        if (!isVisitorRole && !isLoginRole) {\n            await assignToken(method);\n        }\n        return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);\n    };\n    const onResponseRefreshToken = onRespondedHandlers => {\n        const respondedRecord = onResponded2Record(onRespondedHandlers);\n        return {\n            ...respondedRecord,\n            onSuccess: async (response, method) => {\n                if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) &&\n                    !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) &&\n                    !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta)) {\n                    const dataResent = await refreshTokenIfExpired(method, waitingList, refreshing => {\n                        tokenRefreshing = refreshing;\n                    }, [response, method], refreshTokenOnSuccess, tokenRefreshing);\n                    if (dataResent) {\n                        return dataResent;\n                    }\n                }\n                await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);\n                await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);\n                return (respondedRecord.onSuccess || $self)(response, method);\n            },\n            onError: async (error, method) => {\n                if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) &&\n                    !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) &&\n                    !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {\n                    const dataResent = await refreshTokenIfExpired(method, waitingList, refreshing => {\n                        tokenRefreshing = refreshing;\n                    }, [error, method], refreshTokenOnError, tokenRefreshing);\n                    if (dataResent) {\n                        return dataResent;\n                    }\n                }\n                return (respondedRecord.onError || noop)(error, method);\n            }\n        };\n    };\n    return {\n        waitingList,\n        onAuthRequired,\n        onResponseRefreshToken\n    };\n};\n\nconst coreAssert = createAssert('');\nconst requestHookAssert = createAssert('useRequest');\nconst watcherHookAssert = createAssert('useWatcher');\nconst fetcherHookAssert = createAssert('useFetcher');\nconst coreHookAssert = (hookType) => ({\n    [1 /* EnumHookType.USE_REQUEST */]: requestHookAssert,\n    [2 /* EnumHookType.USE_WATCHER */]: watcherHookAssert,\n    [3 /* EnumHookType.USE_FETCHER */]: fetcherHookAssert\n})[hookType];\n/**\n * 断言是否为method实例\n * @param methodInstance method实例\n */\nconst assertMethod = (assert, methodInstance) => assert(instanceOf(methodInstance, Method), 'expected a method instance.');\n\n/**\n * 兼容函数，抛出参数\n * @param error 错误\n */\nconst throwFn = (error) => {\n    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n    throw error;\n};\nfunction useCallback(onCallbackChange = noop) {\n    let callbacks = [];\n    const setCallback = (fn) => {\n        if (!callbacks.includes(fn)) {\n            callbacks.push(fn);\n            onCallbackChange(callbacks);\n        }\n        // 返回取消注册函数\n        return () => {\n            callbacks = filterItem$1(callbacks, e => e !== fn);\n            onCallbackChange(callbacks);\n        };\n    };\n    const triggerCallback = (...args) => {\n        if (callbacks.length > 0) {\n            return forEach(callbacks, fn => fn(...args));\n        }\n    };\n    const removeAllCallback = () => {\n        callbacks = [];\n        onCallbackChange(callbacks);\n    };\n    return [setCallback, triggerCallback, removeAllCallback];\n}\n/**\n * 创建防抖函数，当delay为0时立即触发函数\n * 场景：在调用useWatcher并设置了immediate为true时，首次调用需立即执行，否则会造成延迟调用\n * @param {GeneralFn} fn 回调函数\n * @param {number|(...args: any[]) => number} delay 延迟描述，设置为函数时可实现动态的延迟\n * @returns 延迟后的回调函数\n */\nconst debounce = (fn, delay) => {\n    let timer = nullValue;\n    return function debounceFn(...args) {\n        const bindFn = fn.bind(this, ...args);\n        const delayMill = isNumber(delay) ? delay : delay(...args);\n        timer && clearTimeoutTimer(timer);\n        if (delayMill > 0) {\n            timer = setTimeoutFn(bindFn, delayMill);\n        }\n        else {\n            bindFn();\n        }\n    };\n};\n/**\n * 获取请求方法对象\n * @param methodHandler 请求方法句柄\n * @param args 方法调用参数\n * @returns 请求方法对象\n */\nconst getHandlerMethod = (methodHandler, args = []) => {\n    const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;\n    createAssert('scene')(instanceOf(methodInstance, Method), 'hook handler must be a method instance or a function that returns method instance');\n    return methodInstance;\n};\n/**\n * 转换对象的每一项值，并返回新的对象\n * @param obj 对象\n * @param callback 回调函数\n * @returns 转换后的对象\n */\nconst mapObject = (obj, callback) => {\n    const ret = {};\n    for (const key in obj) {\n        ret[key] = callback(obj[key], key, obj);\n    }\n    return ret;\n};\n\n/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nconst undefStr = 'undefined';\nconst pushItem = (ary, ...item) => ary.push(...item);\nconst mapItem = (ary, callbackfn) => ary.map(callbackfn);\nconst filterItem = (ary, predicate) => ary.filter(predicate);\n// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断\n// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用\n// 因此使用服务端独有的 process.cwd 函数作为判断依据\ntypeof window === undefStr &&\n    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);\n\n/**\n * 创建uuid简易版\n * @returns uuid\n */\nconst uuid = () => {\n    const timestamp = new Date().getTime();\n    return Math.floor(Math.random() * timestamp).toString(36);\n};\n\nconst createEventManager = () => {\n    const eventMap = {};\n    return {\n        eventMap,\n        on(type, handler) {\n            const eventTypeItem = (eventMap[type] = eventMap[type] || []);\n            pushItem(eventTypeItem, handler);\n            // return the off function\n            return () => {\n                eventMap[type] = filterItem(eventTypeItem, item => item !== handler);\n            };\n        },\n        off(type, handler) {\n            const handlers = eventMap[type];\n            if (!handlers) {\n                return;\n            }\n            if (handler) {\n                const index = handlers.indexOf(handler);\n                index > -1 && handlers.splice(index, 1);\n            }\n            else {\n                delete eventMap[type];\n            }\n        },\n        emit(type, event) {\n            const handlers = eventMap[type] || [];\n            return mapItem(handlers, handler => handler(event));\n        }\n    };\n};\nconst decorateEvent = (onEvent, decoratedHandler) => {\n    const emitter = createEventManager();\n    const eventType = uuid();\n    const eventReturn = onEvent(event => emitter.emit(eventType, event));\n    return (handler) => {\n        emitter.on(eventType, event => {\n            decoratedHandler(handler, event);\n        });\n        return eventReturn;\n    };\n};\n\nconst KEY_SUCCESS = 'success';\nconst KEY_ERROR = 'error';\nconst KEY_COMPLETE = 'complete';\n\nvar createHook = (ht, c, eventManager, ro) => ({\n    /** 最后一次请求的method实例 */\n    m: undefinedValue,\n    /** saveStatesFns */\n    sf: [],\n    /** removeStatesFns */\n    rf: [],\n    /** frontStates */\n    fs: {},\n    /** eventManager */\n    em: eventManager,\n    /** hookType, useRequest=1, useWatcher=2, useFetcher=3 */\n    ht,\n    /** hook config */\n    c,\n    /** referingObject */\n    ro,\n    /** managedStates */\n    ms: {}\n});\n\n/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nclass AlovaEventBase {\n    constructor(method, args) {\n        this.method = method;\n        this.args = args;\n    }\n    clone() {\n        return { ...this };\n    }\n    static spawn(method, args) {\n        return new AlovaEventBase(method, args);\n    }\n}\nclass AlovaSuccessEvent extends AlovaEventBase {\n    constructor(base, data, fromCache) {\n        super(base.method, base.args);\n        this.data = data;\n        this.fromCache = fromCache;\n    }\n}\nclass AlovaErrorEvent extends AlovaEventBase {\n    constructor(base, error) {\n        super(base.method, base.args);\n        this.error = error;\n    }\n}\nclass AlovaCompleteEvent extends AlovaEventBase {\n    constructor(base, status, data, fromCache, error) {\n        super(base.method, base.args);\n        this.status = status;\n        this.data = data;\n        this.fromCache = status === 'error' ? false : fromCache;\n        this.error = error;\n    }\n}\n\nconst defaultMiddleware = (_, next) => next();\n\nconst stateCache = {};\n/**\n * @description 获取State缓存数据\n * @param baseURL 基础URL\n * @param key 请求key值\n * @returns 缓存的响应数据，如果没有则返回{}\n */\nconst getStateCache = (namespace, key) => {\n    const cachedState = stateCache[namespace] || {};\n    return cachedState[key] || {};\n};\n/**\n * @description 设置State缓存数据\n * @param baseURL 基础URL\n * @param key 请求key值\n * @param data 缓存数据\n */\nconst setStateCache = (namespace, key, data, hookInstance) => {\n    const cachedState = (stateCache[namespace] = stateCache[namespace] || {});\n    cachedState[key] = {\n        s: data,\n        h: hookInstance\n    };\n};\n/**\n * @description 清除State缓存数据\n * @param baseURL 基础URL\n * @param key 请求key值\n */\nconst removeStateCache = (namespace, key) => {\n    const cachedState = stateCache[namespace];\n    if (cachedState) {\n        deleteAttr(cachedState, key);\n    }\n};\n\n/**\n * 统一处理useRequest/useWatcher/useFetcher等请求钩子函数的请求逻辑\n * @param hookInstance hook实例\n * @param methodHandler 请求方法对象或获取函数\n * @param sendCallingArgs send函数参数\n * @returns 请求状态\n */\nfunction useHookToSendRequest(hookInstance, methodHandler, sendCallingArgs = []) {\n    const currentHookAssert = coreHookAssert(hookInstance.ht);\n    let methodInstance = getHandlerMethod$1(methodHandler, currentHookAssert, sendCallingArgs);\n    const { fs: frontStates, ht: hookType, c: useHookConfig, ms: managedStates } = hookInstance;\n    const { loading: loadingState, data: dataState, error: errorState } = frontStates;\n    const isFetcher = hookType === 3 /* EnumHookType.USE_FETCHER */;\n    const { force: forceRequest = falseValue, middleware = defaultMiddleware } = useHookConfig;\n    const alovaInstance = getContext(methodInstance);\n    const { id } = alovaInstance;\n    // 如果是静默请求，则请求后直接调用onSuccess，不触发onError，然后也不会更新progress\n    const methodKey = getMethodInternalKey(methodInstance);\n    const { abortLast = trueValue } = useHookConfig;\n    hookInstance.m = methodInstance;\n    return (async () => {\n        // 初始化状态数据，在拉取数据时不需要加载，因为拉取数据不需要返回data数据\n        let removeStates = noop;\n        let saveStates = noop;\n        let isNextCalled = falseValue;\n        let responseHandlePromise = promiseResolve(undefinedValue);\n        let offDownloadEvent = noop;\n        let offUploadEvent = noop;\n        const cachedResponse = await queryCache(methodInstance);\n        let fromCache = () => !!cachedResponse;\n        // 是否为受控的loading状态，当为true时，响应处理中将不再设置loading为false\n        let controlledLoading = falseValue;\n        if (!isFetcher) {\n            // 将初始状态存入缓存以便后续更新\n            saveStates = frontStates => setStateCache(id, methodKey, frontStates, hookInstance);\n            saveStates({ ...frontStates, ...managedStates });\n            // 设置状态移除函数，将会传递给hook内的effectRequest，它将被设置在组件卸载时调用\n            removeStates = () => removeStateCache(id, methodKey);\n        }\n        // 中间件函数next回调函数，允许修改强制请求参数，甚至替换即将发送请求的Method实例\n        const guardNext = guardNextConfig => {\n            isNextCalled = trueValue;\n            const { force: guardNextForceRequest = forceRequest, method: guardNextReplacingMethod = methodInstance } = guardNextConfig || {};\n            const forceRequestFinally = sloughConfig(guardNextForceRequest, [\n                newInstance((AlovaEventBase), methodInstance, sendCallingArgs)\n            ]);\n            const progressUpdater = (stage) => ({ loaded, total }) => {\n                frontStates[stage].v = {\n                    loaded,\n                    total\n                };\n            };\n            methodInstance = guardNextReplacingMethod;\n            // 每次发送请求都需要保存最新的控制器\n            pushItem$1(hookInstance.sf, saveStates);\n            pushItem$1(hookInstance.rf, removeStates);\n            // loading状态受控时将不更改loading\n            // 未命中缓存，或强制请求时需要设置loading为true\n            if (!controlledLoading) {\n                loadingState.v = !!forceRequestFinally || !cachedResponse;\n            }\n            // 根据downloading、uploading的追踪状态来判断是否触发进度更新\n            const { downloading: enableDownload, uploading: enableUpload } = hookInstance.ro.trackedKeys;\n            offDownloadEvent = enableDownload ? methodInstance.onDownload(progressUpdater('downloading')) : offDownloadEvent;\n            offUploadEvent = enableUpload ? methodInstance.onUpload(progressUpdater('uploading')) : offUploadEvent;\n            responseHandlePromise = methodInstance.send(forceRequestFinally);\n            fromCache = () => methodInstance.fromCache || falseValue;\n            return responseHandlePromise;\n        };\n        // 调用中间件函数\n        const commonContext = {\n            method: methodInstance,\n            cachedResponse,\n            config: useHookConfig,\n            abort: () => methodInstance.abort()\n        };\n        // 是否需要更新响应数据，以及调用响应回调\n        const toUpdateResponse = () => hookType !== 2 /* EnumHookType.USE_WATCHER */ || !abortLast || hookInstance.m === methodInstance;\n        // 调用中间件函数\n        const middlewareCompletePromise = isFetcher\n            ? middleware({\n                ...commonContext,\n                args: sendCallingArgs,\n                fetch: (methodInstance, ...args) => {\n                    assertMethod(currentHookAssert, methodInstance);\n                    return useHookToSendRequest(hookInstance, methodInstance, args);\n                },\n                proxyStates: omit(frontStates, 'data'),\n                controlFetching(control = trueValue) {\n                    controlledLoading = control;\n                }\n            }, guardNext)\n            : middleware({\n                ...commonContext,\n                args: sendCallingArgs,\n                send: (...args) => useHookToSendRequest(hookInstance, methodHandler, args),\n                proxyStates: frontStates,\n                controlLoading(control = trueValue) {\n                    controlledLoading = control;\n                }\n            }, guardNext);\n        let finallyResponse = undefinedValue;\n        const baseEvent = AlovaEventBase.spawn(methodInstance, sendCallingArgs);\n        try {\n            // 统一处理响应\n            const middlewareReturnedData = await middlewareCompletePromise;\n            const afterSuccess = (data) => {\n                // 更新缓存响应数据\n                if (!isFetcher) {\n                    toUpdateResponse() && (dataState.v = data);\n                }\n                else if (hookInstance.c.updateState !== falseValue) {\n                    // 更新缓存内的状态，一般为useFetcher中进入\n                    const cachedState = getStateCache(id, methodKey).s;\n                    cachedState && (cachedState.data.v = data);\n                }\n                // 如果需要更新响应数据，则在请求后触发对应回调函数\n                if (toUpdateResponse()) {\n                    errorState.v = undefinedValue;\n                    // loading状态受控时将不再更改为false\n                    !controlledLoading && (loadingState.v = falseValue);\n                    hookInstance.em.emit(KEY_SUCCESS, newInstance((AlovaSuccessEvent), baseEvent, data, fromCache()));\n                    hookInstance.em.emit(KEY_COMPLETE, newInstance((AlovaCompleteEvent), baseEvent, KEY_SUCCESS, data, fromCache(), undefinedValue));\n                }\n                return data;\n            };\n            finallyResponse =\n                // 中间件中未返回数据或返回undefined时，去获取真实的响应数据\n                // 否则使用返回数据并不再等待响应promise，此时也需要调用响应回调\n                middlewareReturnedData !== undefinedValue\n                    ? afterSuccess(middlewareReturnedData)\n                    : isNextCalled\n                        ? // 当middlewareCompletePromise为resolve时有两种可能\n                            // 1. 请求正常\n                            // 2. 请求错误，但错误被中间件函数捕获了，此时也将调用成功回调，即afterSuccess(undefinedValue)\n                            await promiseThen(responseHandlePromise, afterSuccess, () => afterSuccess(undefinedValue))\n                        : // 如果isNextCalled未被调用，则不返回数据\n                            undefinedValue;\n            // 未调用next函数时，更新loading为false\n            !isNextCalled && !controlledLoading && (loadingState.v = falseValue);\n        }\n        catch (error) {\n            if (toUpdateResponse()) {\n                // 控制在输出错误消息\n                errorState.v = error;\n                // loading状态受控时将不再更改为false\n                !controlledLoading && (loadingState.v = falseValue);\n                hookInstance.em.emit(KEY_ERROR, newInstance((AlovaErrorEvent), baseEvent, error));\n                hookInstance.em.emit(KEY_COMPLETE, newInstance((AlovaCompleteEvent), baseEvent, KEY_ERROR, undefinedValue, fromCache(), error));\n            }\n            throw error;\n        }\n        // 响应后解绑下载和上传事件\n        offDownloadEvent();\n        offUploadEvent();\n        return finallyResponse;\n    })();\n}\n\nconst refCurrent = (ref) => ref.current;\n/**\n * 创建请求状态，统一处理useRequest、useWatcher、useFetcher中一致的逻辑\n * 该函数会调用statesHook的创建函数来创建对应的请求状态\n * 当该值为空时，表示useFetcher进入的，此时不需要data状态和缓存状态\n * @param methodInstance 请求方法对象\n * @param useHookConfig hook请求配置对象\n * @param initialData 初始data数据\n * @param immediate 是否立即发起请求\n * @param watchingStates 被监听的状态，如果未传入，直接调用handleRequest\n * @param debounceDelay 请求发起的延迟时间\n * @returns 当前的请求状态、操作函数及事件绑定函数\n */\nfunction createRequestState(hookType, methodHandler, useHookConfig, initialData, immediate = falseValue, watchingStates, debounceDelay = 0) {\n    var _a;\n    // shallow clone config object to avoid passing the same useHookConfig object which may cause vue2 state update error\n    useHookConfig = { ...useHookConfig };\n    const { middleware, __referingObj: referingObject = { trackedKeys: {}, bindError: falseValue } } = useHookConfig;\n    let initialLoading = middleware ? falseValue : !!immediate;\n    // 当立即发送请求时，需要通过是否强制请求和是否有缓存来确定初始loading值，这样做有以下两个好处：\n    // 1. 在react下立即发送请求可以少渲染一次\n    // 2. SSR渲染的html中，其初始视图为loading状态的，避免在客户端展现时的loading视图闪动\n    // 3. 如果config.middleware中设置了`controlLoading`时，需要默认为false，但这边无法确定middleware中是否有调用`controlLoading`，因此条件只能放宽点，当有`config.middleware`时则初始`loading`为false\n    if (immediate && !middleware) {\n        // 调用getHandlerMethod时可能会报错，需要try/catch\n        try {\n            const methodInstance = getHandlerMethod$1(methodHandler, coreHookAssert(hookType));\n            const alovaInstance = getContext(methodInstance);\n            const l1CacheResult = alovaInstance.l1Cache.get(buildNamespacedCacheKey(alovaInstance.id, getMethodInternalKey(methodInstance)));\n            let cachedResponse = undefinedValue;\n            // 只同步检查缓存，因此对异步的l1Cache适配器不生效\n            // 建议在客户端不设置异步的l1Cache适配器\n            if (l1CacheResult && !instanceOf(l1CacheResult, PromiseCls)) {\n                const [data, expireTimestamp] = l1CacheResult;\n                // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期\n                if (!expireTimestamp || expireTimestamp > getTime()) {\n                    cachedResponse = data;\n                }\n            }\n            const forceRequestFinally = sloughConfig((_a = useHookConfig.force) !== null && _a !== void 0 ? _a : falseValue);\n            initialLoading = !!forceRequestFinally || !cachedResponse;\n        }\n        catch (error) { }\n    }\n    const { create, effectRequest, ref, objectify, exposeProvider, transformState2Proxy } = statesHookHelper(promiseStatesHook(), referingObject);\n    const progress = {\n        total: 0,\n        loaded: 0\n    };\n    // 将外部传入的受监管的状态一同放到frontStates集合中\n    const { managedStates = {} } = useHookConfig;\n    const managedStatesProxy = mapObject(managedStates, (state, key) => transformState2Proxy(state, key));\n    const data = create((isFn(initialData) ? initialData() : initialData), 'data');\n    const loading = create(initialLoading, 'loading');\n    const error = create(undefinedValue, 'error');\n    const downloading = create({ ...progress }, 'downloading');\n    const uploading = create({ ...progress }, 'uploading');\n    const frontStates = objectify([data, loading, error, downloading, uploading]);\n    const eventManager = createEventManager();\n    const hookInstance = refCurrent(ref(createHook(hookType, useHookConfig, eventManager, referingObject)));\n    /**\n     * ## react ##每次执行函数都需要重置以下项\n     */\n    hookInstance.fs = frontStates;\n    hookInstance.em = eventManager;\n    hookInstance.c = useHookConfig;\n    hookInstance.ms = managedStatesProxy;\n    const hasWatchingStates = watchingStates !== undefinedValue;\n    // 初始化请求事件\n    // 统一的发送请求函数\n    const handleRequest = (handler = methodHandler, sendCallingArgs) => useHookToSendRequest(hookInstance, handler, sendCallingArgs);\n    // 以捕获异常的方式调用handleRequest\n    // 捕获异常避免异常继续向外抛出\n    const wrapEffectRequest = (ro = referingObject, handler) => promiseCatch(handleRequest(handler), error => {\n        // the error tracking indicates that the error need to throw.\n        if (!ro.bindError && !ro.trackedKeys.error) {\n            throw error;\n        }\n    });\n    /**\n     * fix: #421\n     * Use ref wraps to prevent react from creating new debounce function in every render\n     * Explicit passing is required because the context will change\n     */\n    const debouncingSendHandler = ref(debounce((delay, ro, handler) => wrapEffectRequest(ro, handler), (changedIndex) => isNumber(changedIndex) ? (isArray(debounceDelay) ? debounceDelay[changedIndex] : debounceDelay) : 0));\n    // 在服务端渲染时不发送请求\n    if (!globalConfigMap.ssr) {\n        effectRequest({\n            handler: \n            // watchingStates为数组时表示监听状态（包含空数组），为undefined时表示不监听状态\n            hasWatchingStates\n                ? (delay) => debouncingSendHandler.current(delay, referingObject, methodHandler)\n                : () => wrapEffectRequest(referingObject),\n            removeStates: () => forEach(hookInstance.rf, fn => fn()),\n            saveStates: states => forEach(hookInstance.sf, fn => fn(states)),\n            frontStates: { ...frontStates, ...managedStatesProxy },\n            watchingStates,\n            immediate: immediate !== null && immediate !== void 0 ? immediate : trueValue\n        });\n    }\n    return exposeProvider({\n        ...objectify([data, loading, error, downloading, uploading]),\n        abort: () => hookInstance.m && hookInstance.m.abort(),\n        /**\n         * 通过执行该方法来手动发起请求\n         * @param sendCallingArgs 调用send函数时传入的参数\n         * @param methodInstance 方法对象\n         * @param isFetcher 是否为isFetcher调用\n         * @returns 请求promise\n         */\n        send: (sendCallingArgs, methodInstance) => handleRequest(methodInstance, sendCallingArgs),\n        onSuccess(handler) {\n            eventManager.on(KEY_SUCCESS, handler);\n        },\n        onError(handler) {\n            // will not throw error when bindError is true.\n            // it will reset in `exposeProvider` so that ignore the error binding in custom use hooks.\n            referingObject.bindError = trueValue;\n            eventManager.on(KEY_ERROR, handler);\n        },\n        onComplete(handler) {\n            eventManager.on(KEY_COMPLETE, handler);\n        }\n    });\n}\n\n/**\n * Fetch request data and cache\n * @param method request method object\n */\nfunction useFetcher(config = {}) {\n    const props = createRequestState(3 /* EnumHookType.USE_FETCHER */, noop, config);\n    const { send } = props;\n    deleteAttr(props, 'send');\n    return objAssign(props, {\n        /**\n         * Fetch data\n         * fetch will definitely send a request, and if the currently requested data has a corresponding management state, this state will be updated.\n         * @param matcher Method object\n         */\n        fetch: (matcher, ...args) => {\n            assertMethod(fetcherHookAssert, matcher);\n            return send(args, matcher);\n        }\n    });\n}\n\nfunction useRequest(handler, config = {}) {\n    const { immediate = trueValue, initialData } = config;\n    const props = createRequestState(1 /* EnumHookType.USE_REQUEST */, handler, config, initialData, !!immediate);\n    const { send } = props;\n    return objAssign(props, {\n        send: (...args) => send(args)\n    });\n}\n\nfunction useWatcher(handler, watchingStates, config = {}) {\n    watcherHookAssert(watchingStates && len(watchingStates) > 0, 'expected at least one watching state');\n    const { immediate, debounce = 0, initialData } = config;\n    const props = createRequestState(2 /* EnumHookType.USE_WATCHER */, handler, config, initialData, !!immediate, // !!immediate means not send request immediately\n    watchingStates, debounce);\n    const { send } = props;\n    return objAssign(props, {\n        send: (...args) => send(args)\n    });\n}\n\n/**\n * 断言serialHandlers\n * @param hookName hook name\n * @param serialHandlers 串行请求method获取函数\n */\nconst assertSerialHandlers = (hookName, serialHandlers) => createAssert(hookName)(isArray(serialHandlers) && len(serialHandlers) > 0, 'please use an array to represent serial requests');\n/**\n * 创建串行请求中间件\n * @param serialHandlers 串行请求method获取函数\n * @param hookMiddleware use hook的中间件\n * @returns 串行请求中间件\n */\nconst serialMiddleware = (serialHandlers, hookMiddleware, serialRequestMethods = []) => {\n    // 第一个handler在外部传递给了use hook，不需要再次请求\n    serialHandlers.shift();\n    return ((ctx, next) => {\n        hookMiddleware === null || hookMiddleware === void 0 ? void 0 : hookMiddleware(ctx, () => promiseResolve(undefinedValue));\n        ctx.controlLoading();\n        const loadingState = ctx.proxyStates.loading;\n        loadingState.v = trueValue;\n        let serialPromise = next();\n        for (const handler of serialHandlers) {\n            serialPromise = promiseThen(serialPromise, value => {\n                const methodItem = handler(value, ...ctx.args);\n                pushItem$1(serialRequestMethods, methodItem);\n                return methodItem.send();\n            });\n        }\n        return serialPromise.finally(() => {\n            loadingState.v = falseValue;\n        });\n    });\n};\n\n/**\n * 串行请求hook，每个serialHandlers中将接收到上一个请求的结果\n * 适用场景：串行请求一组接口\n * @param serialHandlers 串行请求回调数组\n * @param config 配置参数\n * @return useSerialRequest相关数据和操作函数\n */\nvar useSerialRequest = (serialHandlers, config = {}) => {\n    assertSerialHandlers('useSerialRequest', serialHandlers);\n    // eslint-disable-next-line\n    const { ref, __referingObj } = statesHookHelper(promiseStatesHook());\n    const methods = ref([]).current;\n    const exposures = useRequest(serialHandlers[0], {\n        ...config,\n        __referingObj,\n        middleware: serialMiddleware(serialHandlers, config.middleware, methods)\n    });\n    // 装饰错误回调函数，将event.method设置为出错的实例\n    exposures.onError = decorateEvent(exposures.onError, (handler, event) => {\n        event.method = methods[len(methods) - 1];\n        handler(event);\n    });\n    return exposures;\n};\n\n/**\n * 串行请求hook，每个serialHandlers中将接收到上一个请求的结果\n * 适用场景：监听状态变化后，串行请求一组接口\n * @param serialHandlers 串行请求回调数组\n * @param config 配置参数\n * @return useSerialRequest相关数据和操作函数\n */\nvar useSerialWatcher = (serialHandlers, watchingStates, config = {}) => {\n    assertSerialHandlers('useSerialWatcher', serialHandlers);\n    // eslint-disable-next-line\n    const { ref, __referingObj } = statesHookHelper(promiseStatesHook());\n    const methods = ref([]).current;\n    const exposures = useWatcher(serialHandlers[0], watchingStates, {\n        ...config,\n        __referingObj,\n        middleware: serialMiddleware(serialHandlers, config.middleware, methods)\n    });\n    // 装饰错误回调函数，将event.method设置为出错的实例\n    exposures.onError = decorateEvent(exposures.onError, (handler, event) => {\n        event.method = methods[len(methods) - 1];\n        handler(event);\n    });\n    return exposures;\n};\n\nconst STR_VALUE_OF = 'valueOf';\nconst DEFAULT_QUEUE_NAME = 'default';\nconst BEHAVIOR_SILENT = 'silent';\nconst BEHAVIOR_QUEUE = 'queue';\nconst BEHAVIOR_STATIC = 'static';\n/**\n * 全局的虚拟数据收集数组\n * 它只会在method创建时为数组，其他时间为undefined\n *\n * 解释：收集虚拟数据的目的为了判断某个method实例内是否使用了虚拟数据\n * 包括以下形式：\n * useSQRequest((vDataId) => createMethod({ vDataId }) // 引用函数参数\n * useSQRequest(() => createMethod({ vDataId }) // 直接引用作用域参数\n *\n * 甚至是：\n * function createMethod(obj) {\n *   return alovaInst.Get('/list', {\n *     params: { status: obj.vDataId ? 1 : 0 }\n *   })\n * }\n * useSQRequest(() => createMethod(obj) // 直接引用作用域参数\n *\n * 使用虚拟数据的方式包含：\n * 1. 直接作为参数赋值\n * 2. 使用虚拟数据id\n * 3. 间接使用虚拟数据，如\n *    vData ? 1 : 0\n *    !!vData\n *    vData + 1\n *    等作为计算参数参与的形式\n */\nlet vDataIdCollectBasket;\nconst setVDataIdCollectBasket = (value) => {\n    vDataIdCollectBasket = value;\n};\n/**\n * 依赖的alova实例，它的存储适配器、请求适配器等将用于存取SilentMethod实例，以及发送静默提交\n */\nlet dependentAlovaInstance;\nconst setDependentAlova = (alovaInst) => {\n    dependentAlovaInstance = alovaInst;\n};\n/**\n * 设置自定义的序列化器\n */\nlet customSerializers = {};\nconst setCustomSerializers = (serializers = {}) => {\n    customSerializers = serializers;\n};\n/**\n * silentFactory状态\n * 0表示未启动\n * 1表示进行中，调用bootSilentFactory后变更\n * 2表示请求失败，即按重试规则请求达到最大次数时，或不匹配重试规则时变更\n */\nlet silentFactoryStatus = 0;\nconst setSilentFactoryStatus = (status) => {\n    silentFactoryStatus = status;\n};\n/**\n * silentQueue内的请求等待时间，单位为毫秒（ms）\n * 它表示即将发送请求的silentMethod的等待时间\n * 如果未设置，或设置为0表示立即触发silentMethod请求\n *\n * Tips:\n * 1. 直接设置时默认对default queue有效\n * 2. 如果需要对其他queue设置可指定为对象，如：\n * [\n *   表示对名为customName的队列设置请求等待5000ms\n *   { name: 'customName', wait: 5000 },\n *\n *   // 表示前缀为prefix的所有队列中，method实例名为xxx的请求设置等待5000ms\n *   { name: /^prefix/, wait: silentMethod => silentMethod.entity.config.name === 'xxx' ? 5000 : 0 },\n * ]\n *\n * >>> 它只在请求成功时起作用，如果失败则会使用重试策略参数\n */\nlet queueRequestWaitSetting = [];\nconst setQueueRequestWaitSetting = (requestWaitSetting = 0) => {\n    queueRequestWaitSetting = isArray(requestWaitSetting)\n        ? requestWaitSetting\n        : [\n            {\n                queue: DEFAULT_QUEUE_NAME,\n                wait: requestWaitSetting\n            }\n        ];\n};\nconst BootEventKey = Symbol('GlobalSQBoot');\nconst BeforeEventKey = Symbol('GlobalSQBefore');\nconst SuccessEventKey = Symbol('GlobalSQSuccess');\nconst ErrorEventKey = Symbol('GlobalSQError');\nconst FailEventKey$1 = Symbol('GlobalSQFail');\n/** 全局的silent事件管理对象 */\nconst globalSQEventManager = createEventManager();\n/** silentAssert */\nconst silentAssert = createAssert('useSQRequest');\n\nclass AlovaSSEEvent extends AlovaEventBase {\n    constructor(base, eventSource) {\n        super(base.method, base.args);\n        this.eventSource = eventSource;\n    }\n}\nclass AlovaSSEErrorEvent extends AlovaSSEEvent {\n    constructor(base, error) {\n        super(base, base.eventSource);\n        this.error = error;\n    }\n}\nclass AlovaSSEMessageEvent extends AlovaSSEEvent {\n    constructor(base, data) {\n        super(base, base.eventSource);\n        this.data = data;\n    }\n}\n/** SQ顶层事件 */\nclass SQEvent {\n    constructor(behavior, method, silentMethod) {\n        this.behavior = behavior;\n        this.method = method;\n        this.silentMethod = silentMethod;\n    }\n}\n/** SQ全局事件 */\nclass GlobalSQEvent extends SQEvent {\n    constructor(behavior, method, silentMethod, queueName, retryTimes) {\n        super(behavior, method, silentMethod);\n        this.queueName = queueName;\n        this.retryTimes = retryTimes;\n    }\n}\nclass GlobalSQSuccessEvent extends GlobalSQEvent {\n    constructor(behavior, method, silentMethod, queueName, retryTimes, data, vDataResponse) {\n        super(behavior, method, silentMethod, queueName, retryTimes);\n        this.data = data;\n        this.vDataResponse = vDataResponse;\n    }\n}\nclass GlobalSQErrorEvent extends GlobalSQEvent {\n    constructor(behavior, method, silentMethod, queueName, retryTimes, error, retryDelay) {\n        super(behavior, method, silentMethod, queueName, retryTimes);\n        this.error = error;\n        this.retryDelay = retryDelay;\n    }\n}\nclass GlobalSQFailEvent extends GlobalSQEvent {\n    constructor(behavior, method, silentMethod, queueName, retryTimes, error) {\n        super(behavior, method, silentMethod, queueName, retryTimes);\n        this.error = error;\n    }\n}\n/** SQ事件 */\nclass ScopedSQEvent extends SQEvent {\n    constructor(behavior, method, silentMethod, args) {\n        super(behavior, method, silentMethod);\n        this.args = args;\n    }\n}\nclass ScopedSQSuccessEvent extends ScopedSQEvent {\n    constructor(behavior, method, silentMethod, args, data) {\n        super(behavior, method, silentMethod, args);\n        this.data = data;\n    }\n}\nclass ScopedSQErrorEvent extends ScopedSQEvent {\n    constructor(behavior, method, silentMethod, args, error) {\n        super(behavior, method, silentMethod, args);\n        this.error = error;\n    }\n}\nclass ScopedSQRetryEvent extends ScopedSQEvent {\n    constructor(behavior, method, silentMethod, args, retryTimes, retryDelay) {\n        super(behavior, method, silentMethod, args);\n        this.retryTimes = retryTimes;\n        this.retryDelay = retryDelay;\n    }\n}\nclass ScopedSQCompleteEvent extends ScopedSQEvent {\n    constructor(behavior, method, silentMethod, args, status, data, error) {\n        super(behavior, method, silentMethod, args);\n        this.status = status;\n        this.data = data;\n        this.error = error;\n    }\n}\nclass RetriableRetryEvent extends AlovaEventBase {\n    constructor(base, retryTimes, retryDelay) {\n        super(base.method, base.args);\n        this.retryTimes = retryTimes;\n        this.retryDelay = retryDelay;\n    }\n}\nclass RetriableFailEvent extends AlovaErrorEvent {\n    constructor(base, error, retryTimes) {\n        super(base, error);\n        this.retryTimes = retryTimes;\n    }\n}\n\n/**\n * 更新对应method的状态\n * @param method 请求方法对象\n * @param handleUpdate 更新回调\n * @returns 是否更新成功，未找到对应的状态时不会更新成功\n */\nasync function updateState(matcher, handleUpdate) {\n    let updated = falseValue;\n    // 只处理符合条件的第一个Method实例，如果没有符合条件的实例，则不处理\n    if (matcher) {\n        const { update } = promiseStatesHook();\n        const methodKey = getMethodInternalKey(matcher);\n        const { id } = getContext(matcher);\n        const { s: frontStates, h: hookInstance } = getStateCache(id, methodKey);\n        const updateStateCollection = isFn(handleUpdate)\n            ? { data: handleUpdate }\n            : handleUpdate;\n        let updatedDataColumnData = undefinedValue;\n        if (frontStates) {\n            // 循环遍历更新数据，并赋值给受监管的状态\n            forEach(objectKeys(updateStateCollection), stateName => {\n                coreAssert(stateName in frontStates, `state named \\`${stateName}\\` is not found`);\n                const targetStateProxy = frontStates[stateName];\n                let updatedData = updateStateCollection[stateName](targetStateProxy.v);\n                // shallow clone the updatedData so that can effect in react.\n                updatedData = isArray(updatedData)\n                    ? [...updatedData]\n                    : isObject(updatedData)\n                        ? { ...updatedData }\n                        : updatedData;\n                // 记录data字段的更新值，用于更新缓存数据\n                if (stateName === 'data') {\n                    updatedDataColumnData = updatedData;\n                }\n                // 直接使用update更新，不检查referingObject.trackedKeys\n                update(updatedData, frontStates[stateName].s, stateName, hookInstance.ro);\n            });\n            updated = trueValue;\n        }\n        // 如果更新了data，则需要同时更新缓存和持久化数据\n        if (updatedDataColumnData !== undefinedValue) {\n            setCache(matcher, updatedDataColumnData);\n        }\n    }\n    return updated;\n}\n\nvar dateSerializer = {\n    forward: data => (instanceOf(data, Date) ? data.getTime() : undefinedValue),\n    backward: ts => newInstance(Date, ts)\n};\n\nvar regexpSerializer = {\n    forward: data => (instanceOf(data, RegExp) ? data.source : undefined),\n    backward: source => newInstance(RegExp, source)\n};\n\nconst createSerializerPerformer = (customSerializers = {}) => {\n    /**\n     * 合并内置序列化器和自定义序列化器\n     */\n    const serializers = {\n        date: dateSerializer,\n        regexp: regexpSerializer,\n        ...customSerializers\n    };\n    /**\n     * 序列化数据\n     */\n    const serialize = (payload) => {\n        if (isObject(payload)) {\n            payload = walkObject(isArray(payload) ? [...payload] : { ...payload }, value => {\n                let finallyApplySerializerName = undefinedValue;\n                // 找到匹配的序列化器并进行值的序列化，未找到则返回原值\n                const serializedValue = objectKeys(serializers).reduce((currentValue, serializerName) => {\n                    if (!finallyApplySerializerName) {\n                        const serializedValueItem = serializers[serializerName].forward(currentValue);\n                        if (serializedValueItem !== undefinedValue) {\n                            finallyApplySerializerName = serializerName;\n                            currentValue = serializedValueItem;\n                        }\n                    }\n                    return currentValue;\n                }, value);\n                // 需要用原始值判断，否则像new Number(1)等包装类也会是[object Object]\n                const toStringTag = ObjectCls.prototype.toString.call(value);\n                if (toStringTag === '[object Object]') {\n                    value = { ...value };\n                }\n                else if (isArray(value)) {\n                    value = [...value];\n                }\n                return finallyApplySerializerName !== undefinedValue ? [finallyApplySerializerName, serializedValue] : value;\n            });\n        }\n        return payload;\n    };\n    /**\n     * 反序列化数据\n     */\n    const deserialize = (payload) => isObject(payload)\n        ? walkObject(payload, value => {\n            if (isArray(value) && len(value) === 2) {\n                const foundSerializer = serializers[value[0]];\n                value = foundSerializer ? foundSerializer.backward(value[1]) : value;\n            }\n            return value;\n        }, falseValue)\n        : payload;\n    return {\n        serialize,\n        deserialize\n    };\n};\n\nconst symbolVDataId = Symbol('vdid');\nconst symbolOriginal = Symbol('original');\nconst regVDataId = /\\[vd:([0-9a-z]+)\\]/;\n\n/**\n * 统一的vData收集函数\n * 它将在以下4个位置被调用\n * 1. 访问子属性时\n * 2. 参与计算并触发[Symbol.toPrimitive]时\n * 3. 获取vData的id时\n * 4. 获取其原始值时\n *\n * @param returnValue 返回值，如果是函数则调用它\n * @returns 收集函数\n */\nconst vDataCollectUnified = (target) => {\n    const vDataId = target === null || target === void 0 ? void 0 : target[symbolVDataId];\n    vDataId && vDataIdCollectBasket && (vDataIdCollectBasket[vDataId] = undefinedValue);\n};\n// export const vDataGetter = (key: string) => vDataCollectGetter((thisObj: any) => thisObj.__proto__[key].call(thisObj));\n\n/**\n * 虚拟数据字符串化，如果参数不是虚拟数据则返回原数据\n * @param target 虚拟数据\n * @param returnOriginalIfNotVData 如果不是虚拟数据则返回原值\n * @returns 虚拟数据id或原数据\n */\nconst stringifyVData = (target, returnOriginalIfNotVData = trueValue) => {\n    vDataCollectUnified(target);\n    const vDataIdRaw = target === null || target === void 0 ? void 0 : target[symbolVDataId];\n    const vDataId = vDataIdRaw ? `[vd:${vDataIdRaw}]` : undefinedValue;\n    return vDataId || (returnOriginalIfNotVData ? target : undefinedValue);\n};\n/**\n * 创建虚拟数据id收集的getter函数\n * @param valueReturnFn 返回值函数\n * @returns getter函数\n */\nfunction stringifyWithThis() {\n    return stringifyVData(this);\n}\n\n/**\n * Null包装类实现\n */\nconst Null = function Null() { };\nNull.prototype = ObjectCls.create(nullValue, {\n    [STR_VALUE_OF]: valueObject(stringifyWithThis)\n});\n\n/**\n * Undefined包装类实现\n */\nconst Undefined = function Undefined() { };\nUndefined.prototype = ObjectCls.create(nullValue, {\n    [STR_VALUE_OF]: valueObject(stringifyWithThis)\n});\n\n/**\n * 创建虚拟响应数据\n * @returns 虚拟响应数据代理实例\n */\nvar createVirtualResponse = (structure, vDataId = uuid$1()) => {\n    const transform2VData = (value, vDataIdInner = uuid$1()) => {\n        if (value === nullValue) {\n            value = newInstance(Null);\n        }\n        else if (value === undefinedValue) {\n            value = newInstance(Undefined);\n        }\n        else {\n            const newValue = ObjectCls(value);\n            defineProperty(newValue, STR_VALUE_OF, stringifyWithThis);\n            defineProperty(newValue, symbolOriginal, value);\n            value = newValue;\n        }\n        defineProperty(value, symbolVDataId, vDataIdInner);\n        return value;\n    };\n    const virtualResponse = transform2VData(structure, vDataId);\n    if (isPlainObject(virtualResponse) || isArray(virtualResponse)) {\n        walkObject(virtualResponse, value => transform2VData(value));\n    }\n    return virtualResponse;\n};\n\n/**\n * 获取带虚拟数据变量的原始值\n * 此函数也将会进行vData收集\n * @param target 目标值\n * @param deepDehydrate 是否深度脱水值\n * @returns 具有原始类型的目标值\n */\nconst dehydrateVDataUnified = (target, deepDehydrate = trueValue) => {\n    const dehydrateItem = (value) => {\n        vDataCollectUnified(value);\n        if (value === null || value === void 0 ? void 0 : value[symbolVDataId]) {\n            if (instanceOf(value, Undefined)) {\n                value = undefinedValue;\n            }\n            else if (instanceOf(value, Null)) {\n                value = nullValue;\n            }\n            else if (instanceOf(value, Number) || instanceOf(value, String) || instanceOf(value, Boolean)) {\n                value = value[symbolOriginal];\n            }\n        }\n        return value;\n    };\n    const newTarget = dehydrateItem(target);\n    // 如果是对象或数组，需要深度遍历获取虚拟数据值\n    if (deepDehydrate && (isObject(newTarget) || isArray(newTarget))) {\n        walkObject(newTarget, value => dehydrateItem(value));\n    }\n    return newTarget;\n};\n/**\n * 上面函数deepDehydrate为true的版本\n */\nvar dehydrateVData = (target) => dehydrateVDataUnified(target);\n\nconst vDataKey = '__$k';\nconst vDataValueKey = '__$v';\nconst getAlovaStorage = () => {\n    // 未启动silentFactory时提供提示\n    silentAssert(!!dependentAlovaInstance, 'alova instance is not found, Do you forget to set `alova` or call `bootSilentFactory`?');\n    return dependentAlovaInstance.l2Cache;\n};\nlet serializerPerformer = undefinedValue;\nconst silentMethodIdQueueMapStorageKey = 'alova.SQ'; // silentMethod实例id组成的队列集合缓存key\nconst silentMethodStorageKeyPrefix = 'alova.SM.'; // silentMethod实例缓存key前缀\n/**\n * 持久化带虚拟数据和可序列化的数据集合\n * @param key 持久化key\n * @param payload 持久化数据\n */\nconst storageSetItem = async (key, payload) => {\n    const storage = getAlovaStorage();\n    if (isObject(payload)) {\n        payload = walkObject(isArray(payload) ? [...payload] : { ...payload }, (value, key, parent) => {\n            var _a;\n            if (key === vDataValueKey && parent[vDataKey]) {\n                return value;\n            }\n            // 如果序列化的是silentMethod实例，则过滤掉alova实例\n            if (key === 'context' && ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Alova') {\n                return undefinedValue;\n            }\n            const vDataId = value === null || value === void 0 ? void 0 : value[symbolVDataId];\n            let primitiveValue = dehydrateVDataUnified(value, falseValue);\n            // 需要用原始值判断，否则像new Number(1)等包装类也会是[object Object]\n            const toStringTag = globalToString(primitiveValue);\n            if (toStringTag === '[object Object]') {\n                value = { ...value };\n                primitiveValue = {};\n            }\n            else if (isArray(value)) {\n                value = [...value];\n                primitiveValue = [];\n            }\n            if (vDataId) {\n                const valueWithVData = {\n                    [vDataKey]: vDataId,\n                    // 对于对象和数组来说，它内部的属性会全部通过`...value`放到外部，因此内部的不需要再进行遍历转换了\n                    // 因此将数组或对象置空，这样既避免了重复转换，又避免了污染原对象\n                    [vDataValueKey]: primitiveValue,\n                    ...value\n                };\n                // 如果是String类型，将会有像数组一样的如0、1、2为下标，值为字符的项，需将他们过滤掉\n                if (instanceOf(value, String)) {\n                    for (let i = 0; i < len(value); i += 1) {\n                        valueWithVData === null || valueWithVData === void 0 ? true : delete valueWithVData[i];\n                    }\n                }\n                // 如果转换成了虚拟数据，则将转换值赋给它内部，并在下面逻辑中统一由value处理\n                value = valueWithVData;\n            }\n            return value;\n        });\n    }\n    serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);\n    await storage.set(key, serializerPerformer.serialize(payload));\n};\n/**\n * 取出持久化数据，并将数据转换为虚拟数据和已序列化数据\n * @param key 持久化数据的key\n */\nconst storageGetItem = async (key) => {\n    const storagedResponse = await getAlovaStorage().get(key);\n    serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);\n    return isObject(storagedResponse)\n        ? walkObject(serializerPerformer.deserialize(storagedResponse), value => {\n            // 将虚拟数据格式转换回虚拟数据实例\n            if (isObject(value) && (value === null || value === void 0 ? void 0 : value[vDataKey])) {\n                const vDataId = value[vDataKey];\n                const vDataValue = createVirtualResponse(value[vDataValueKey], vDataId);\n                forEach(objectKeys(value), key => {\n                    if (!includes([vDataKey, vDataValueKey], key)) {\n                        vDataValue[key] = value[key];\n                    }\n                });\n                value = vDataValue;\n            }\n            return value;\n        }, falseValue)\n        : storagedResponse;\n};\n/**\n * 移除持久化数据\n * @param key 持久化数据的key\n */\nconst storageRemoveItem = async (key) => {\n    await getAlovaStorage().remove(key);\n};\n\n/**\n * 序列化并保存silentMethod实例\n * @param silentMethodInstance silentMethod实例\n */\nconst persistSilentMethod = (silentMethodInstance) => storageSetItem(silentMethodStorageKeyPrefix + silentMethodInstance.id, silentMethodInstance);\n/**\n * 将静默请求的配置信息放入对应storage中\n * 逻辑：通过构造一个key，并用这个key将静默方法的配置信息放入对应storage中，然后将key存入统一管理key的存储中\n * @param silentMethod SilentMethod实例\n * @param queue 操作的队列名\n */\nconst push2PersistentSilentQueue = async (silentMethodInstance, queueName) => {\n    await persistSilentMethod(silentMethodInstance);\n    // 将silentMethod实例id保存到queue存储中\n    const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||\n        {});\n    const currentQueue = (silentMethodIdQueueMap[queueName] = silentMethodIdQueueMap[queueName] || []);\n    pushItem$1(currentQueue, silentMethodInstance.id);\n    await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);\n};\n/**\n * 对缓存中的silentMethod实例移除或替换\n * @param queue 操作的队列名\n * @param targetSilentMethodId 目标silentMethod实例id\n * @param newSilentMethod 替换的新silentMethod实例，未传则表示删除\n */\nconst spliceStorageSilentMethod = async (queueName, targetSilentMethodId, newSilentMethod) => {\n    // 将silentMethod实例id从queue中移除\n    const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||\n        {});\n    const currentQueue = silentMethodIdQueueMap[queueName] || [];\n    const index = currentQueue.findIndex(id => id === targetSilentMethodId);\n    if (index >= 0) {\n        if (newSilentMethod) {\n            splice(currentQueue, index, 1, newSilentMethod.id);\n            await persistSilentMethod(newSilentMethod);\n        }\n        else {\n            splice(currentQueue, index, 1);\n        }\n        await storageRemoveItem(silentMethodStorageKeyPrefix + targetSilentMethodId);\n        // 队列为空时删除此队列\n        len(currentQueue) <= 0 && delete silentMethodIdQueueMap[queueName];\n        if (len(objectKeys(silentMethodIdQueueMap)) > 0) {\n            await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);\n        }\n        else {\n            // 队列集合为空时移除它\n            await storageRemoveItem(silentMethodIdQueueMapStorageKey);\n        }\n    }\n};\n\n/** 静默方法队列集合 */\nlet silentQueueMap = {};\n/**\n * 合并queueMap到silentMethod队列集合\n * @param queueMap silentMethod队列集合\n */\nconst merge2SilentQueueMap = (queueMap) => {\n    forEach(objectKeys(queueMap), targetQueueName => {\n        const currentQueue = (silentQueueMap[targetQueueName] = silentQueueMap[targetQueueName] || []);\n        pushItem$1(currentQueue, ...queueMap[targetQueueName]);\n    });\n};\n/**\n * 深层遍历目标数据，并将虚拟数据替换为实际数据\n * @param target 目标数据\n * @param vDataResponse 虚拟数据和实际数据的集合\n * @returns 是否有替换数据\n */\nconst deepReplaceVData = (target, vDataResponse) => {\n    // 搜索单一值并将虚拟数据对象或虚拟数据id替换为实际值\n    const replaceVData = (value) => {\n        const vData = stringifyVData(value);\n        // 如果直接是虚拟数据对象并且在vDataResponse中，则使用vDataResponse中的值替换Map\n        // 如果是字符串，则里面可能包含虚拟数据id并且在vDataResponse中，也需将它替换为实际值Map\n        // 不在本次vDataResponse中的虚拟数据将不变，它可能是下一次请求的虚拟数据Map\n        if (vData in vDataResponse) {\n            return vDataResponse[vData];\n        }\n        if (isString(value)) {\n            return value.replace(newInstance(RegExpCls, regVDataId.source, 'g'), mat => mat in vDataResponse ? vDataResponse[mat] : mat);\n        }\n        return value;\n    };\n    if (isObject(target) && !stringifyVData(target, falseValue)) {\n        walkObject(target, replaceVData);\n    }\n    else {\n        target = replaceVData(target);\n    }\n    return target;\n};\n/**\n * 更新队列内的method实例，将虚拟数据替换为实际数据\n * @param vDataResponse 虚拟id和对应真实数据的集合\n * @param targetQueue 目标队列\n */\nconst updateQueueMethodEntities = (vDataResponse, targetQueue) => PromiseCls.all(mapItem$1(targetQueue, async (silentMethodItem) => {\n    // 深层遍历entity对象，如果发现有虚拟数据或虚拟数据id，则替换为实际数据\n    deepReplaceVData(silentMethodItem.entity, vDataResponse);\n    // 如果method实例有更新，则重新持久化此silentMethod实例\n    silentMethodItem.cache && (await persistSilentMethod(silentMethodItem));\n}));\n/**\n * 使用响应数据替换虚拟数据\n * @param response 真实响应数据\n * @param virtualResponse 虚拟响应数据\n * @returns 虚拟数据id所构成的对应真实数据集合\n */\nconst replaceVirtualResponseWithResponse = (virtualResponse, response) => {\n    let vDataResponse = {};\n    const vDataId = stringifyVData(virtualResponse, falseValue);\n    vDataId && (vDataResponse[vDataId] = response);\n    if (isObject(virtualResponse)) {\n        for (const i in virtualResponse) {\n            vDataResponse = {\n                ...vDataResponse,\n                ...replaceVirtualResponseWithResponse(virtualResponse[i], response === null || response === void 0 ? void 0 : response[i])\n            };\n        }\n    }\n    return vDataResponse;\n};\n/**\n * 启动SilentMethod队列\n * 1. 静默提交将会放入队列中，并按顺序发送请求，只有等到前一个请求响应后才继续发送后面的请求\n * 2. 重试次数只有在未响应时才触发，在服务端响应错误或断网情况下，不会重试\n * 3. 在达到重试次数仍未成功时，当设置了nextRound（下一轮）时延迟nextRound指定的时间后再次请求，否则将在刷新后再次尝试\n * 4. 如果有resolveHandler和rejectHandler，将在请求完成后（无论成功还是失败）调用，通知对应的请求继续响应\n *\n * @param queue SilentMethod队列\n */\nconst setSilentMethodActive = (silentMethodInstance, active) => {\n    if (active) {\n        silentMethodInstance.active = active;\n    }\n    else {\n        delete silentMethodInstance.active;\n    }\n};\nconst defaultBackoffDelay = 1000;\nconst bootSilentQueue = (queue, queueName) => {\n    /**\n     * 根据请求等待参数控制回调函数的调用，如果未设置或小于等于0则立即触发\n     * @param queueName 队列名称\n     * @param callback 回调函数\n     */\n    const emitWithRequestDelay = (queueName) => {\n        const nextSilentMethod = queue[0];\n        if (nextSilentMethod) {\n            const targetSetting = queueRequestWaitSetting.find(({ queue }) => instanceOf(queue, RegExpCls) ? regexpTest(queue, queueName) : queue === queueName);\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            const callback = () => queue[0] && silentMethodRequest(queue[0]);\n            const delay = (targetSetting === null || targetSetting === void 0 ? void 0 : targetSetting.wait) ? sloughConfig(targetSetting.wait, [nextSilentMethod, queueName]) : 0;\n            delay && delay > 0 ? setTimeoutFn(callback, delay) : callback();\n        }\n    };\n    /**\n     * 运行单个silentMethod实例\n     * @param silentMethodInstance silentMethod实例\n     * @param retryTimes 重试的次数\n     */\n    const silentMethodRequest = (silentMethodInstance, retryTimes = 0) => {\n        // 将当前silentMethod实例设置活跃状态\n        setSilentMethodActive(silentMethodInstance, trueValue);\n        const { cache, id, behavior, entity, retryError = /.*/, maxRetryTimes = 0, backoff = { delay: defaultBackoffDelay }, resolveHandler = noop, rejectHandler = noop, emitter: methodEmitter, handlerArgs = [], virtualResponse, force } = silentMethodInstance;\n        // 触发请求前事件\n        globalSQEventManager.emit(BeforeEventKey, newInstance((GlobalSQEvent), behavior, entity, silentMethodInstance, queueName, retryTimes));\n        promiseThen(entity.send(force), async (data) => {\n            // 请求成功，移除成功的silentMethod实力，并继续下一个请求\n            shift(queue);\n            // 请求成功，把成功的silentMethod实例在storage中移除，并继续下一个请求\n            cache && (await spliceStorageSilentMethod(queueName, id));\n            // 如果有resolveHandler则调用它通知外部\n            resolveHandler(data);\n            // 有virtualResponse时才遍历替换虚拟数据，且触发全局事件\n            // 一般为silent behavior，而queue behavior不需要\n            if (behavior === BEHAVIOR_SILENT) {\n                // 替换队列中后面方法实例中的虚拟数据为真实数据\n                // 开锁后才能正常访问virtualResponse的层级结构\n                const vDataResponse = replaceVirtualResponseWithResponse(virtualResponse, data);\n                const { targetRefMethod, updateStates } = silentMethodInstance; // 实时获取才准确\n                // 如果此silentMethod带有targetRefMethod，则再次调用updateState更新数据\n                // 此为延迟数据更新的实现\n                if (instanceOf(targetRefMethod, Method) && updateStates && len(updateStates) > 0) {\n                    const updateStateCollection = {};\n                    forEach(updateStates, stateName => {\n                        // 请求成功后，将带有虚拟数据的数据替换为实际数据\n                        updateStateCollection[stateName] = dataRaw => deepReplaceVData(dataRaw, vDataResponse);\n                    });\n                    const updated = updateState(targetRefMethod, updateStateCollection);\n                    // 修改状态不成功，则去修改缓存数据\n                    if (!updated) {\n                        await setCache(targetRefMethod, (dataRaw) => deepReplaceVData(dataRaw, vDataResponse));\n                    }\n                }\n                // 对当前队列的后续silentMethod实例进行虚拟数据替换\n                await updateQueueMethodEntities(vDataResponse, queue);\n                // 触发全局的成功事件\n                globalSQEventManager.emit(SuccessEventKey, newInstance((GlobalSQSuccessEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, data, vDataResponse));\n            }\n            // 设为非激活状态\n            setSilentMethodActive(silentMethodInstance, falseValue);\n            // 继续下一个silentMethod的处理\n            emitWithRequestDelay(queueName);\n        }, reason => {\n            if (behavior !== BEHAVIOR_SILENT) {\n                // 当behavior不为silent时，请求失败就触发rejectHandler\n                // 且在队列中移除，并不再重试\n                shift(queue);\n                rejectHandler(reason);\n            }\n            else {\n                // 每次请求错误都将触发错误回调\n                const runGlobalErrorEvent = (retryDelay) => globalSQEventManager.emit(ErrorEventKey, newInstance((GlobalSQErrorEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, reason, retryDelay));\n                // 在silent行为模式下，判断是否需要重试\n                // 重试只有在响应错误符合retryError正则匹配时有效\n                const { name: errorName = '', message: errorMsg = '' } = reason || {};\n                let regRetryErrorName;\n                let regRetryErrorMsg;\n                if (instanceOf(retryError, RegExp)) {\n                    regRetryErrorMsg = retryError;\n                }\n                else if (isObject(retryError)) {\n                    regRetryErrorName = retryError.name;\n                    regRetryErrorMsg = retryError.message;\n                }\n                const matchRetryError = (regRetryErrorName && regexpTest(regRetryErrorName, errorName)) ||\n                    (regRetryErrorMsg && regexpTest(regRetryErrorMsg, errorMsg));\n                // 如果还有重试次数则进行重试\n                if (retryTimes < maxRetryTimes && matchRetryError) {\n                    // 需要使用下次的retryTimes来计算延迟时间，因此这边需+1\n                    const retryDelay = delayWithBackoff(backoff, retryTimes + 1);\n                    runGlobalErrorEvent(retryDelay);\n                    setTimeoutFn(() => {\n                        retryTimes += 1;\n                        silentMethodRequest(silentMethodInstance, retryTimes);\n                        methodEmitter.emit('retry', newInstance((ScopedSQRetryEvent), behavior, entity, silentMethodInstance, handlerArgs, retryTimes, retryDelay));\n                    }, \n                    // 还有重试次数时使用timeout作为下次请求时间\n                    retryDelay);\n                }\n                else {\n                    setSilentFactoryStatus(2);\n                    runGlobalErrorEvent();\n                    // 达到失败次数，或不匹配重试的错误信息时，触发失败回调\n                    methodEmitter.emit('fallback', newInstance((ScopedSQErrorEvent), behavior, entity, silentMethodInstance, handlerArgs, reason));\n                    globalSQEventManager.emit(FailEventKey$1, newInstance((GlobalSQFailEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, reason));\n                }\n            }\n            // 设为非激活状态\n            setSilentMethodActive(silentMethodInstance, falseValue);\n        });\n    };\n    emitWithRequestDelay(queueName);\n};\n/**\n * 将新的silentMethod实例放入队列中\n * @param silentMethodInstance silentMethod实例\n * @param cache silentMethod是否有缓存\n * @param targetQueueName 目标队列名\n * @param onBeforePush silentMethod实例push前的事件\n */\nconst pushNewSilentMethod2Queue = async (silentMethodInstance, cache, targetQueueName = DEFAULT_QUEUE_NAME, onBeforePush = () => []) => {\n    silentMethodInstance.cache = cache;\n    const currentQueue = (silentQueueMap[targetQueueName] =\n        silentQueueMap[targetQueueName] || []);\n    const isNewQueue = len(currentQueue) <= 0;\n    const beforePushReturns = await Promise.all(onBeforePush());\n    const isPush2Queue = !beforePushReturns.some(returns => returns === falseValue);\n    // silent行为下，如果没有绑定fallback事件回调，则持久化\n    // 如果在onBeforePushQueue返回false，也不再放入队列中\n    if (isPush2Queue) {\n        cache && (await push2PersistentSilentQueue(silentMethodInstance, targetQueueName));\n        pushItem$1(currentQueue, silentMethodInstance);\n        // 如果是新的队列且状态为已启动，则执行它\n        isNewQueue && silentFactoryStatus === 1 && bootSilentQueue(currentQueue, targetQueueName);\n    }\n    return isPush2Queue;\n};\n\n/**\n * 定位silentMethod实例所在的位置\n * @param silentMethodInstance silentMethod实例\n */\nconst getBelongQueuePosition = (silentMethodInstance) => {\n    let queue = undefinedValue;\n    let queueName = '';\n    let position = 0;\n    for (const queueNameLoop in silentQueueMap) {\n        position = silentQueueMap[queueNameLoop].indexOf(silentMethodInstance);\n        if (position >= 0) {\n            queue = silentQueueMap[queueNameLoop];\n            queueName = queueNameLoop;\n            break;\n        }\n    }\n    return [queue, queueName, position];\n};\n/**\n * silentMethod实例\n * 需要进入silentQueue的请求都将被包装成silentMethod实例，它将带有请求策略的各项参数\n */\nclass SilentMethod {\n    constructor(entity, behavior, emitter, id = uuid$1(), force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDatas) {\n        const thisObj = this;\n        thisObj.entity = entity;\n        thisObj.behavior = behavior;\n        thisObj.id = id;\n        thisObj.emitter = emitter;\n        thisObj.force = !!force;\n        thisObj.retryError = retryError;\n        thisObj.maxRetryTimes = maxRetryTimes;\n        thisObj.backoff = backoff;\n        thisObj.resolveHandler = resolveHandler;\n        thisObj.rejectHandler = rejectHandler;\n        thisObj.handlerArgs = handlerArgs;\n        thisObj.vDatas = vDatas;\n    }\n    /**\n     * 允许缓存时持久化更新当前实例\n     */\n    async save() {\n        this.cache && (await persistSilentMethod(this));\n    }\n    /**\n     * 在队列中使用一个新的silentMethod实例替换当前实例\n     * 如果有持久化缓存也将会更新缓存\n     * @param newSilentMethod 新的silentMethod实例\n     */\n    async replace(newSilentMethod) {\n        const targetSilentMethod = this;\n        silentAssert(newSilentMethod.cache === targetSilentMethod.cache, 'the cache of new silentMethod must equal with this silentMethod');\n        const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);\n        if (queue) {\n            splice(queue, position, 1, newSilentMethod);\n            targetSilentMethod.cache && (await spliceStorageSilentMethod(queueName, targetSilentMethod.id, newSilentMethod));\n        }\n    }\n    /**\n     * 移除当前实例，如果有持久化数据，也会同步移除\n     */\n    async remove() {\n        const targetSilentMethod = this;\n        const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);\n        if (queue) {\n            splice(queue, position, 1);\n            targetSilentMethod.cache && (await spliceStorageSilentMethod(queueName, targetSilentMethod.id));\n        }\n    }\n    /**\n     * 设置延迟更新状态对应的method实例以及对应的状态名\n     * 它将在此silentMethod响应后，找到对应的状态数据并将vData更新为实际数据\n     *\n     * @param method method实例\n     * @param updateStateName 更新的状态名，默认为data，也可以设置多个\n     */\n    setUpdateState(method, updateStateName = 'data') {\n        if (method) {\n            this.targetRefMethod = method;\n            this.updateStates = isArray(updateStateName) ? updateStateName : [updateStateName];\n        }\n    }\n}\n\n/**\n * 反序列化silentMethod实例，根据序列化器的名称进行反序列化\n * @param methodInstance 请求方法实例\n * @returns 请求方法实例\n */\nvar convertPayload2SilentMethod = (payload) => {\n    const { id, behavior, entity, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, targetRefMethod, force } = payload;\n    // method类实例化\n    const deserializeMethod = (methodPayload) => {\n        const { type, url, config, data } = methodPayload;\n        return newInstance(Method, type, dependentAlovaInstance, url, config, data);\n    };\n    const silentMethodInstance = newInstance(SilentMethod, deserializeMethod(entity), behavior, createEventManager(), id, force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs);\n    silentMethodInstance.cache = trueValue;\n    // targetRefMethod反序列化\n    if (targetRefMethod) {\n        silentMethodInstance.targetRefMethod = deserializeMethod(targetRefMethod);\n    }\n    // 将额外的内容放到silentMethod实例上\n    forEach(objectKeys(payload), key => {\n        if (!includes([\n            'id',\n            'behavior',\n            'emitter',\n            'entity',\n            'retryError',\n            'maxRetryTimes',\n            'backoff',\n            'resolveHandler',\n            'rejectHandler',\n            'handlerArgs',\n            'targetRefMethod',\n            'force'\n        ], key)) {\n            silentMethodInstance[key] = payload[key];\n        }\n    });\n    return silentMethodInstance;\n};\n\n/**\n * 从storage中载入静默队列数据\n * @returns 所有队列数据\n */\nvar loadSilentQueueMapFromStorage = async () => {\n    const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||\n        {});\n    const silentQueueMap = {};\n    const readingPromises = [];\n    forEach(objectKeys(silentMethodIdQueueMap), queueName => {\n        const currentQueue = (silentQueueMap[queueName] = silentQueueMap[queueName] || []);\n        pushItem$1(readingPromises, ...mapItem$1(silentMethodIdQueueMap[queueName], async (silentMethodId) => {\n            const serializedSilentMethodPayload = await storageGetItem(silentMethodStorageKeyPrefix + silentMethodId);\n            serializedSilentMethodPayload &&\n                pushItem$1(currentQueue, convertPayload2SilentMethod(serializedSilentMethodPayload));\n        }));\n    });\n    await PromiseCls.all(readingPromises);\n    return silentQueueMap;\n};\n\n/**\n * 绑定silentSubmit启动事件\n * @param {SilentSubmitBootHandler} handler 事件回调函数\n * @returns 解绑函数\n */\nconst onSilentSubmitBoot = (handler) => globalSQEventManager.on(BootEventKey, handler);\n/**\n * 绑定silentSubmit成功事件\n * @param {SilentSubmitSuccessHandler} handler 事件回调函数\n * @returns 解绑函数\n */\nconst onSilentSubmitSuccess = (handler) => globalSQEventManager.on(SuccessEventKey, handler);\n/**\n * 绑定silentSubmit错误事件\n * 每次请求错误，触发错误回调\n * @param {SilentSubmitErrorHandler} handler 事件回调函数\n * @returns 解绑函数\n */\nconst onSilentSubmitError = (handler) => globalSQEventManager.on(ErrorEventKey, handler);\n/**\n * 绑定silentSubmit失败事件\n * 失败事件将在最大请求次数到达，或不匹配错误信息时触发\n * @param {SilentSubmitFailHandler} handler 事件回调函数\n * @returns 解绑函数\n */\nconst onSilentSubmitFail = (handler) => globalSQEventManager.on(FailEventKey$1, handler);\n/**\n * 绑定silentSubmit发起请求前事件\n * @param {BeforeSilentSubmitHandler} handler 事件回调函数\n * @returns 解绑函数\n */\nconst onBeforeSilentSubmit = (handler) => globalSQEventManager.on(BeforeEventKey, handler);\n/**\n * 启动静默提交，它将载入缓存中的静默方法，并开始静默提交\n * 如果未传入延迟时间，则立即同步启动\n * @param {SilentFactoryBootOptions} options 延迟毫秒数\n */\nconst bootSilentFactory = (options) => {\n    if (silentFactoryStatus === 0) {\n        const { alova, delay = 500 } = options;\n        setDependentAlova(alova);\n        setCustomSerializers(options.serializers);\n        setQueueRequestWaitSetting(options.requestWait);\n        setTimeoutFn(async () => {\n            // 延时加载，让页面的queue放在最前面\n            merge2SilentQueueMap(await loadSilentQueueMapFromStorage());\n            // 循环启动队列静默提交\n            // 多条队列是并行执行的\n            forEach(objectKeys(silentQueueMap), queueName => {\n                bootSilentQueue(silentQueueMap[queueName], queueName);\n            });\n            setSilentFactoryStatus(1); // 设置状态为已启动\n            globalSQEventManager.emit(BootEventKey, undefinedValue);\n        }, delay);\n    }\n};\n\n/**\n * 以兼容虚拟数据的方式判断两个值是否相等\n * @param prevValue 前项值\n * @param nextValue 后项值\n * @returns 是否相等\n */\nvar equals = (prevValue, nextValue) => {\n    // 如果相等则直接返回\n    if (prevValue === nextValue) {\n        return trueValue;\n    }\n    return stringifyVData(prevValue) === stringifyVData(nextValue);\n};\n\n/**\n * 按method名称或正则表达式筛选满足条件的所有silentMethod实例\n * @param methodNameMatcher method名称匹配器\n * @param queueName 查找队列名，默认为default队列\n * @param filterActive 是否过滤掉激活状态的实例\n * @returns silentMethod实例数组\n */\nconst filterSilentMethods = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => {\n    const matchSilentMethods = (targetQueue = []) => targetQueue.filter(silentMethodItem => {\n        if (methodNameMatcher === undefinedValue) {\n            return trueValue;\n        }\n        const name = getConfig(silentMethodItem.entity).name || '';\n        const retain = instanceOf(methodNameMatcher, RegExp)\n            ? regexpTest(methodNameMatcher, name)\n            : name === methodNameMatcher;\n        return retain && (filterActive ? silentMethodItem.active : trueValue);\n    });\n    return [\n        ...matchSilentMethods(silentQueueMap[queueName]),\n        // 如果当前未启动silentFactory，则还需要去持久化存储中匹配silentMethods\n        ...(silentFactoryStatus === 0 ? matchSilentMethods((await loadSilentQueueMapFromStorage())[queueName]) : [])\n    ];\n};\n/**\n * 按method名称或正则表达式查找第一个满足条件的silentMethod实例\n * @param methodNameMatcher method名称匹配器\n * @param queueName 查找队列名，默认为default队列\n * @param filterActive 是否过滤掉激活状态的实例\n * @returns silentMethod实例，未找到时为undefined\n */\nconst getSilentMethod = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => (await filterSilentMethods(methodNameMatcher, queueName, filterActive))[0];\n\n/**\n * 判断目标数据是否为虚拟数据\n * @param target 目标数据\n * @returns 是否为虚拟数据\n */\nvar isVData = (target) => !!stringifyVData(target, falseValue) || regexpTest(regVDataId, target);\n\n/**\n * 全局的silentMethod实例，它将在第一个成功事件触发前到最后一个成功事件触发后有值（同步时段）\n * 通过此方式让onSuccess中的updateStateEffect内获得当前的silentMethod实例\n */\nlet currentSilentMethod = undefinedValue;\n/**\n * 创建SilentQueue中间件函数\n * @param config 配置对象\n * @returns 中间件函数\n */\nvar createSilentQueueMiddlewares = (handler, config) => {\n    const { behavior = 'queue', queue = DEFAULT_QUEUE_NAME, retryError, maxRetryTimes, backoff } = config || {};\n    const eventEmitter = createEventManager();\n    let handlerArgs;\n    let behaviorFinally;\n    let queueFinally = DEFAULT_QUEUE_NAME;\n    let forceRequest = falseValue;\n    let silentMethodInstance;\n    /**\n     * method实例创建函数\n     * @param args 调用send传入的函数\n     * @returns method实例\n     */\n    const createMethod = (...args) => {\n        silentAssert(isFn(handler), 'method handler must be a function. eg. useSQRequest(() => method)');\n        setVDataIdCollectBasket({});\n        handlerArgs = args;\n        return handler(...args);\n    };\n    // 装饰success/error/complete事件\n    const decorateRequestEvent = (requestExposure) => {\n        // 设置事件回调装饰器\n        requestExposure.onSuccess = decorateEvent(requestExposure.onSuccess, (handler, event) => {\n            currentSilentMethod = silentMethodInstance;\n            handler(newInstance((ScopedSQSuccessEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.data));\n        });\n        requestExposure.onError = decorateEvent(requestExposure.onError, (handler, event) => {\n            handler(newInstance((ScopedSQErrorEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.error));\n        });\n        requestExposure.onComplete = decorateEvent(requestExposure.onComplete, (handler, event) => {\n            handler(newInstance((ScopedSQCompleteEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.status, event.data, event.error));\n        });\n    };\n    /**\n     * 中间件函数\n     * @param context 请求上下文，包含请求相关的值\n     * @param next 继续执行函数\n     * @returns Promise对象\n     */\n    const middleware = ({ method, args, cachedResponse, proxyStates, config }, next) => {\n        const { silentDefaultResponse, vDataCaptured, force = falseValue } = config;\n        // 因为behavior返回值可能会变化，因此每次请求都应该调用它重新获取返回值\n        const baseEvent = AlovaEventBase.spawn(method, args);\n        behaviorFinally = sloughConfig(behavior, [baseEvent]);\n        queueFinally = sloughConfig(queue, [baseEvent]);\n        forceRequest = sloughConfig(force, [baseEvent]);\n        // 置空临时收集变量\n        // 返回前都需要置空它们\n        const resetCollectBasket = () => {\n            setVDataIdCollectBasket((handlerArgs = undefinedValue));\n        };\n        // 如果设置了vDataCaptured，则先判断请求相关的数据是否包含虚拟数据\n        if (isFn(vDataCaptured)) {\n            let hasVData = vDataIdCollectBasket && len(objectKeys(vDataIdCollectBasket)) > 0;\n            if (!hasVData) {\n                const { url, data } = method;\n                const { params, headers } = getConfig(method);\n                walkObject({ url, params, data, headers }, value => {\n                    if (!hasVData && (stringifyVData(value, falseValue) || regexpTest(regVDataId, value))) {\n                        hasVData = trueValue;\n                    }\n                    return value;\n                });\n            }\n            // 如果vDataCaptured有返回数据，则使用它作为响应数据，否则继续请求\n            const customResponse = hasVData ? vDataCaptured(method) : undefinedValue;\n            if (customResponse !== undefinedValue) {\n                resetCollectBasket(); // 被vDataCaptured捕获时的重置\n                return promiseResolve(customResponse);\n            }\n        }\n        if (behaviorFinally !== BEHAVIOR_STATIC) {\n            // 等待队列中的method执行完毕\n            const createSilentMethodPromise = () => {\n                const queueResolvePromise = newInstance(PromiseCls, (resolveHandler, rejectHandler) => {\n                    silentMethodInstance = newInstance((SilentMethod), method, behaviorFinally, eventEmitter, undefinedValue, !!forceRequest, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDataIdCollectBasket && objectKeys(vDataIdCollectBasket));\n                    resetCollectBasket(); // behavior为queue和silent时的重置\n                });\n                // onBeforePush和onPushed事件是同步绑定的，因此需要异步执行入队列才能正常触发事件\n                promiseThen(promiseResolve(undefinedValue), async () => {\n                    const createPushEvent = () => newInstance((ScopedSQEvent), behaviorFinally, method, silentMethodInstance, args);\n                    // 将silentMethod放入队列并持久化\n                    const isPushed = await pushNewSilentMethod2Queue(silentMethodInstance, \n                    // onFallback绑定了事件后，即使是silent行为模式也不再存储\n                    // onFallback会同步调用，因此需要异步判断是否存在fallbackHandlers\n                    len(eventEmitter.eventMap.fallback || []) <= 0 && behaviorFinally === BEHAVIOR_SILENT, queueFinally, \n                    // 执行放入队列前回调，如果返回false则阻止放入队列\n                    () => eventEmitter.emit('beforePushQueue', createPushEvent()));\n                    // 只有在放入队列后，才执行放入队列后的回调\n                    isPushed && eventEmitter.emit('pushedQueue', createPushEvent());\n                });\n                return queueResolvePromise;\n            };\n            if (behaviorFinally === BEHAVIOR_QUEUE) {\n                // 强制请求，或命中缓存时需要更新loading状态\n                const needSendRequest = forceRequest || !cachedResponse;\n                if (needSendRequest) {\n                    // 手动设置为true\n                    proxyStates.loading.v = trueValue;\n                }\n                // 当使用缓存时，直接使用缓存，否则再进入请求队列\n                return needSendRequest ? createSilentMethodPromise() : promiseThen(promiseResolve(cachedResponse));\n            }\n            const silentMethodPromise = createSilentMethodPromise();\n            // 在silent模式下创建虚拟响应数据，虚拟响应数据可生成任意的虚拟数据\n            const virtualResponse = (silentMethodInstance.virtualResponse = createVirtualResponse(isFn(silentDefaultResponse) ? silentDefaultResponse() : undefinedValue));\n            promiseThen(silentMethodPromise, realResponse => {\n                // 获取到真实数据后更新过去\n                proxyStates.data.v = realResponse;\n            });\n            // silent模式下，先立即返回虚拟响应值，然后当真实数据返回时再更新\n            return promiseResolve(virtualResponse);\n        }\n        resetCollectBasket(); // behavior为static时的重置\n        return next();\n    };\n    return {\n        c: createMethod,\n        m: middleware,\n        d: decorateRequestEvent,\n        // 事件绑定函数\n        b: {\n            /**\n             * 绑定回退事件\n             * @param handler 回退事件回调\n             */\n            onFallback: (handler) => {\n                eventEmitter.on('fallback', handler);\n            },\n            /**\n             * 绑定入队列前事件\n             * @param handler 入队列前的事件回调\n             */\n            onBeforePushQueue: (handler) => {\n                eventEmitter.on('beforePushQueue', handler);\n            },\n            /**\n             * 绑定入队列后事件\n             * @param handler 入队列后的事件回调\n             */\n            onPushedQueue: (handler) => {\n                eventEmitter.on('pushedQueue', handler);\n            },\n            /**\n             * 重试事件\n             * @param handler 重试事件回调\n             */\n            onRetry: (handler) => {\n                eventEmitter.on('retry', handler);\n            }\n        }\n    };\n};\n\n/**\n * 更新对应method的状态\n * 与updateState不同的是，除了立即更新状态外，它还会在silent模式下响应后再次更新一次，目的是将虚拟数据替换为实际数据\n * @param method 请求方法对象\n * @param handleUpdate 更新回调\n */\nconst updateStateEffect = async (matcher, handleUpdate) => {\n    // 将目标method实例保存到当前的silentMethod实例\n    if (currentSilentMethod) {\n        currentSilentMethod.setUpdateState(matcher, isFn(updateState) ? undefinedValue : objectKeys(updateState));\n        await currentSilentMethod.save();\n    }\n    return updateState(matcher, handleUpdate);\n};\n\nconst actionsMap = {};\nconst isFrontMiddlewareContext = (context) => !!context.send;\nconst assert$2 = createAssert('subscriber');\n/**\n * 操作函数委托中间件\n * 使用此中间件后可通过accessAction调用委托的函数\n * 可以委托多个相同id\n * 以此来消除组件的层级限制\n * @param id 委托者id\n * @returns alova中间件函数\n */\nconst actionDelegationMiddleware = (id) => {\n    const { ref } = statesHookHelper(promiseStatesHook());\n    const delegated = ref(falseValue);\n    return (context, next) => {\n        // 中间件会重复调用，已经订阅过了就无需再订阅了\n        if (!delegated.current) {\n            const { abort, proxyStates, delegatingActions = {} } = context;\n            const update = (newStates) => {\n                for (const key in newStates) {\n                    proxyStates[key] && (proxyStates[key].v = newStates[key]);\n                }\n            };\n            // 相同id的将以数组形式保存在一起\n            const handlersItems = (actionsMap[id] = actionsMap[id] || []);\n            handlersItems.push(isFrontMiddlewareContext(context)\n                ? {\n                    ...delegatingActions,\n                    send: context.send,\n                    abort,\n                    update\n                }\n                : {\n                    ...delegatingActions,\n                    fetch: context.fetch,\n                    abort,\n                    update\n                });\n            delegated.current = trueValue;\n        }\n        return next();\n    };\n};\n/**\n * 访问操作函数，如果匹配多个则会以此调用onMatch\n * @param id 委托者id，或正则表达式\n * @param onMatch 匹配的订阅者\n * @param silent 默认为 false。如果为 true，不匹配时将不会报错\n */\nconst accessAction = (id, onMatch, silent = false) => {\n    const matched = [];\n    if (typeof id === 'symbol' || isString(id) || isNumber(id)) {\n        actionsMap[id] && pushItem$1(matched, ...actionsMap[id]);\n    }\n    else if (instanceOf(id, RegExp)) {\n        forEach(filterItem$1(objectKeys(actionsMap), idItem => id.test(idItem)), idItem => {\n            pushItem$1(matched, ...actionsMap[idItem]);\n        });\n    }\n    // its opposite expression is too obscure\n    if (matched.length === 0 && !silent) {\n        assert$2(false, `no handler can be matched by using \\`${id.toString()}\\``);\n    }\n    forEach(matched, onMatch);\n};\n\nvar createSnapshotMethodsManager = (handler) => {\n    let methodSnapshots = {};\n    return {\n        snapshots: () => methodSnapshots,\n        save(methodInstance, force = falseValue) {\n            const key = getMethodInternalKey(methodInstance);\n            // 因为无法定位缓存中total数据的位置\n            // 因此这边冗余维护这个字段\n            if (!methodSnapshots[key] || force) {\n                methodSnapshots[key] = {\n                    entity: methodInstance\n                };\n            }\n        },\n        get: (entityOrPage) => methodSnapshots[getMethodInternalKey(instanceOf(entityOrPage, (Method)) ? entityOrPage : handler(entityOrPage))],\n        remove(key) {\n            if (key) {\n                delete methodSnapshots[key];\n            }\n            else {\n                methodSnapshots = {};\n            }\n        }\n    };\n};\n\nconst paginationAssert = createAssert('usePagination');\nconst indexAssert = (index, rawData) => paginationAssert(isNumber(index) && index < len(rawData), 'index must be a number that less than list length');\nvar usePagination = (handler, config = {}) => {\n    const { create, computed, ref, watch, exposeProvider, objectify, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());\n    const { preloadPreviousPage = trueValue, preloadNextPage = trueValue, total: totalGetter = res => res.total, data: dataGetter = res => res.data, append = falseValue, initialPage = 1, initialPageSize = 10, watchingStates = [], initialData, immediate = trueValue, middleware = noop, force = noop, ...others } = config;\n    const handlerRef = ref(handler);\n    const isReset = ref(falseValue); // 用于控制是否重置\n    // 重置期间请求的次数，为了防止重置时重复请求，使用此参数限制请求\n    const page = create(initialPage, 'page');\n    const pageSize = create(initialPageSize, 'pageSize');\n    const data = create((initialData ? dataGetter(initialData) || [] : []), 'data');\n    const total = create(initialData ? totalGetter(initialData) : undefinedValue, 'total');\n    // 保存当前hook所使用到的所有method实例快照\n    const { snapshots: methodSnapshots, get: getSnapshotMethods, save: saveSnapshot, remove: removeSnapshot } = ref(createSnapshotMethodsManager(page => handlerRef.current(page, pageSize.v))).current;\n    const listDataGetter = (rawData) => dataGetter(rawData) || rawData;\n    // 初始化fetcher\n    const fetchStates = useFetcher({\n        __referingObj: referingObject,\n        updateState: falseValue,\n        force: ({ args }) => args[0]\n    });\n    const { loading, fetch, abort: abortFetch, onSuccess: onFetchSuccess } = fetchStates;\n    const fetchingRef = ref(loading);\n    const getHandlerMethod = (refreshPage = page.v) => {\n        const pageSizeVal = pageSize.v;\n        const handlerMethod = handler(refreshPage, pageSizeVal);\n        // 定义统一的额外名称，方便管理\n        saveSnapshot(handlerMethod);\n        return handlerMethod;\n    };\n    // 监听状态变化时，重置page为1\n    watch(watchingStates, () => {\n        page.v = initialPage;\n        isReset.current = trueValue;\n    });\n    // 兼容react，将需要代理的函数存放在此\n    // 这样可以在代理函数中调用到最新的操作函数，避免react闭包陷阱\n    const delegationActions = ref({});\n    // 计算data、total、isLastPage参数\n    const pageCount = computed(() => {\n        const totalVal = total.v;\n        return totalVal !== undefinedValue ? Math.ceil(totalVal / pageSize.v) : undefinedValue;\n    }, [pageSize, total], 'pageCount');\n    const createDelegationAction = (actionName) => (...args) => delegationActions.current[actionName](...args);\n    const states = useWatcher(getHandlerMethod, [...watchingStates, page.e, pageSize.e], {\n        __referingObj: referingObject,\n        immediate,\n        initialData,\n        managedStates: objectify([data, page, pageSize, total], 's'),\n        middleware(ctx, next) {\n            middleware({\n                ...ctx,\n                delegatingActions: {\n                    refresh: createDelegationAction('refresh'),\n                    insert: createDelegationAction('insert'),\n                    remove: createDelegationAction('remove'),\n                    replace: createDelegationAction('replace'),\n                    reload: createDelegationAction('reload'),\n                    getState: (stateKey) => {\n                        const states = {\n                            page,\n                            pageSize,\n                            data,\n                            pageCount,\n                            total,\n                            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                            isLastPage\n                        };\n                        return states[stateKey].v;\n                    }\n                }\n            }, promiseResolve);\n            return next();\n        },\n        force: event => event.args[1] || (isFn(force) ? force(event) : force),\n        ...others\n    });\n    const { send } = states;\n    const nestedData = states.__proxyState('data');\n    // 判断是否可预加载数据\n    const canPreload = async (payload) => {\n        const { rawData = nestedData.v, preloadPage, fetchMethod, forceRequest = falseValue, isNextPage = falseValue } = payload;\n        const { e: expireMilliseconds } = getLocalCacheConfigParam(fetchMethod);\n        // 如果缓存时间小于等于当前时间，表示没有设置缓存，此时不再预拉取数据\n        // 或者已经有缓存了也不预拉取\n        if (expireMilliseconds(MEMORY) <= getTime()) {\n            return falseValue;\n        }\n        if (forceRequest) {\n            return trueValue;\n        }\n        if (await queryCache(fetchMethod)) {\n            return falseValue;\n        }\n        const pageCountVal = pageCount.v;\n        const exceedPageCount = pageCountVal\n            ? preloadPage > pageCountVal\n            : isNextPage // 如果是判断预加载下一页数据且没有pageCount的情况下，通过最后一页数据量是否达到pageSize来判断\n                ? len(listDataGetter(rawData)) < pageSize.v\n                : falseValue;\n        return preloadPage > 0 && !exceedPageCount;\n    };\n    // 预加载下一页数据\n    const fetchNextPage = async (rawData, force = falseValue) => {\n        const nextPage = page.v + 1;\n        const fetchMethod = getHandlerMethod(nextPage);\n        if (preloadNextPage &&\n            (await canPreload({\n                rawData,\n                preloadPage: nextPage,\n                fetchMethod,\n                isNextPage: trueValue,\n                forceRequest: force\n            }))) {\n            promiseCatch(fetch(fetchMethod, force), noop);\n        }\n    };\n    // 预加载上一页数据\n    const fetchPreviousPage = async (rawData) => {\n        const prevPage = page.v - 1;\n        const fetchMethod = getHandlerMethod(prevPage);\n        if (preloadPreviousPage &&\n            (await canPreload({\n                rawData,\n                preloadPage: prevPage,\n                fetchMethod\n            }))) {\n            promiseCatch(fetch(fetchMethod), noop);\n        }\n    };\n    // 如果返回的数据小于pageSize了，则认定为最后一页了\n    const isLastPage = computed(() => {\n        const dataRaw = nestedData.v;\n        if (!dataRaw) {\n            return trueValue;\n        }\n        const statesDataVal = listDataGetter(dataRaw);\n        const pageVal = page.v;\n        const pageCountVal = pageCount.v;\n        const dataLen = isArray(statesDataVal) ? len(statesDataVal) : 0;\n        return pageCountVal ? pageVal >= pageCountVal : dataLen < pageSize.v;\n    }, [page, pageCount, nestedData, pageSize], 'isLastPage');\n    // 更新当前页缓存\n    const updateCurrentPageCache = async () => {\n        const snapshotItem = getSnapshotMethods(page.v);\n        if (snapshotItem) {\n            await setCache(snapshotItem.entity, (rawData) => {\n                // 当关闭缓存时，rawData为undefined\n                if (rawData) {\n                    const cachedListData = listDataGetter(rawData) || [];\n                    splice(cachedListData, 0, len(cachedListData), ...data.v);\n                    return rawData;\n                }\n            });\n        }\n    };\n    onFetchSuccess(({ method, data: rawData }) => {\n        // 处理当fetch还没响应时就翻页到fetch对应的页码时，需要手动更新列表数据\n        const snapshotItem = getSnapshotMethods(page.v);\n        if (snapshotItem && getMethodInternalKey(snapshotItem.entity) === getMethodInternalKey(method)) {\n            // 如果追加数据，才更新data\n            const listData = listDataGetter(rawData); // 更新data参数\n            if (append) {\n                // 下拉加载时需要替换当前页数据\n                const dataRaw = data.v;\n                const pageSizeVal = pageSize.v;\n                // 当做移除操作时，替换的数量小于pageSize，此时dataRaw % pageSizeVal会大于0\n                // 当新增操作时，替换的数量等于pageSize，此时dataRaw % pageSizeVal会等于0，此时不需要替换\n                const replaceNumber = len(dataRaw) % pageSizeVal;\n                if (replaceNumber > 0) {\n                    const rawData = [...data.v];\n                    splice(rawData, (page.v - 1) * pageSizeVal, replaceNumber, ...listData);\n                    data.v = rawData;\n                }\n            }\n            else {\n                data.v = listData;\n            }\n        }\n    });\n    states.onSuccess(({ data: rawData, args: [refreshPage, isRefresh], method }) => {\n        const { total: cachedTotal } = getSnapshotMethods(method) || {};\n        const typedRawData = rawData;\n        total.v = cachedTotal !== undefinedValue ? cachedTotal : totalGetter(typedRawData);\n        if (!isRefresh) {\n            fetchPreviousPage(typedRawData);\n            fetchNextPage(typedRawData);\n        }\n        const pageSizeVal = pageSize.v;\n        const listData = listDataGetter(typedRawData); // 获取数组\n        paginationAssert(isArray(listData), 'Got wrong array, did you return the correct array of list in `data` function');\n        // 如果追加数据，才更新data\n        if (append) {\n            // 如果是reset则先清空数据\n            if (isReset.current) {\n                data.v = [];\n            }\n            if (refreshPage === undefinedValue) {\n                data.v = [...data.v, ...listData];\n            }\n            else if (refreshPage) {\n                const rawData = [...data.v];\n                // 如果是刷新页面，则是替换那一页的数据\n                splice(rawData, (refreshPage - 1) * pageSizeVal, pageSizeVal, ...listData);\n                data.v = rawData;\n            }\n        }\n        else {\n            data.v = listData;\n        }\n    });\n    // 请求成功与否，都要重置isReset\n    states.onComplete(() => {\n        isReset.current = falseValue;\n    });\n    // 获取列表项所在位置\n    const getItemIndex = (item) => {\n        const index = data.v.indexOf(item);\n        paginationAssert(index >= 0, 'item is not found in list');\n        return index;\n    };\n    const { addQueue: add2AsyncQueue, onComplete: onAsyncQueueRunComplete } = ref(createAsyncQueue()).current;\n    /**\n     * 刷新指定页码数据，此函数将忽略缓存强制发送请求\n     * 如果未传入页码则会刷新当前页\n     * 如果传入一个列表项，将会刷新此列表项所在页，只对append模式有效\n     * @param pageOrItemPage 刷新的页码或列表项\n     */\n    const refresh = (pageOrItemPage = page.v) => {\n        let refreshPage = pageOrItemPage;\n        if (append) {\n            if (!isNumber(pageOrItemPage)) {\n                const itemIndex = getItemIndex(pageOrItemPage);\n                refreshPage = Math.floor(itemIndex / pageSize.v) + 1;\n            }\n            paginationAssert(refreshPage <= page.v, \"refresh page can't greater than page\");\n            // 更新当前页数据\n            promiseCatch(send(refreshPage, trueValue), noop);\n        }\n        else {\n            paginationAssert(isNumber(refreshPage), 'unable to calculate refresh page by item in pagination mode');\n            // 页数相等，则刷新当前页，否则fetch数据\n            promiseCatch(refreshPage === page.v\n                ? send(undefinedValue, trueValue)\n                : fetch(handler(refreshPage, pageSize.v), trueValue), noop);\n        }\n    };\n    // 删除除此usehook当前页和下一页的所有相关缓存\n    const invalidatePaginationCache = async (all = falseValue) => {\n        const pageVal = page.v;\n        const snapshotObj = methodSnapshots();\n        let snapshots = objectValues(snapshotObj);\n        if (all) {\n            removeSnapshot();\n        }\n        else {\n            // 筛选出上一页、当前页、下一页的数据\n            const excludeSnapshotKeys = mapItem$1(filterItem$1([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], Boolean), ({ entity }) => getMethodInternalKey(entity));\n            snapshots = mapItem$1(filterItem$1(objectKeys(snapshotObj), key => !includes(excludeSnapshotKeys, key)), key => {\n                const item = snapshotObj[key];\n                delete snapshotObj[key];\n                return item;\n            });\n        }\n        await invalidateCache(mapItem$1(snapshots, ({ entity }) => entity));\n    };\n    // 单独拿出来的原因是\n    // 无论同步调用几次insert、remove，或它们组合调用，reset操作只需要异步执行一次\n    const resetCache = async () => {\n        fetchingRef.current && abortFetch();\n        // 缓存失效\n        await invalidatePaginationCache();\n        // 当下一页的数据量不超过pageSize时，强制请求下一页，因为有请求共享，需要在中断请求后异步执行拉取操作\n        const snapshotItem = getSnapshotMethods(page.v + 1);\n        if (snapshotItem) {\n            const cachedListData = listDataGetter((await queryCache(snapshotItem.entity)) || {}) || [];\n            fetchNextPage(undefinedValue, len(cachedListData) < pageSize.v);\n        }\n    };\n    // 统一更新总条数\n    const updateTotal = (offset) => {\n        if (offset === 0) {\n            return;\n        }\n        // 更新当前页\n        const totalVal = total.v;\n        if (isNumber(totalVal)) {\n            const offsetedTotal = Math.max(totalVal + offset, 0);\n            total.v = offsetedTotal;\n            const pageVal = page.v;\n            // 更新冗余的total字段\n            forEach([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], item => {\n                item && (item.total = offsetedTotal);\n            });\n        }\n    };\n    /**\n     * 插入一条数据\n     * 如果未传入index，将默认插入到最前面\n     * 如果传入一个列表项，将插入到这个列表项的后面，如果列表项未在列表数据中将会抛出错误\n     * @param item 插入项\n     * @param position 插入位置（索引）或列表项\n     */\n    const insert = (item, position = 0) => {\n        onAsyncQueueRunComplete(resetCache); // 执行结束需要重置缓存\n        return add2AsyncQueue(async () => {\n            const index = isNumber(position) ? position : getItemIndex(position) + 1;\n            let popItem = undefinedValue;\n            const rawData = [...data.v];\n            // 当前展示的项数量刚好是pageSize的倍数时，才需要去掉一项数据，保证操作页的数量为pageSize\n            if (len(rawData) % pageSize.v === 0) {\n                popItem = rawData.pop();\n            }\n            // 插入位置为空默认插到最前面\n            splice(rawData, index, 0, item);\n            data.v = rawData;\n            updateTotal(1);\n            // 当前页的缓存同步更新\n            await updateCurrentPageCache();\n            // 如果有pop项，将它放到下一页缓存的头部，与remove的操作保持一致\n            // 这样在同步调用insert和remove时表现才一致\n            if (popItem) {\n                const snapshotItem = getSnapshotMethods(page.v + 1);\n                if (snapshotItem) {\n                    await setCache(snapshotItem.entity, (rawData) => {\n                        if (rawData) {\n                            const cachedListData = listDataGetter(rawData) || [];\n                            cachedListData.unshift(popItem);\n                            cachedListData.pop();\n                            return rawData;\n                        }\n                    });\n                }\n            }\n        });\n    };\n    /**\n     * 移除一条数据\n     * 如果传入的是列表项，将移除此列表项，如果列表项未在列表数据中将会抛出错误\n     * @param position 移除的索引或列表项\n     */\n    const remove = (...positions) => {\n        onAsyncQueueRunComplete(resetCache); // 执行结束需要重置缓存\n        return add2AsyncQueue(async () => {\n            const indexes = mapItem$1(positions, position => {\n                const index = isNumber(position) ? position : getItemIndex(position);\n                indexAssert(index, data.v);\n                return index;\n            });\n            const pageVal = page.v;\n            const nextPage = pageVal + 1;\n            const snapshotItem = getSnapshotMethods(nextPage);\n            const fillingItems = []; // 补位数据项\n            if (snapshotItem) {\n                await setCache(snapshotItem.entity, (rawData) => {\n                    if (rawData) {\n                        const cachedListData = listDataGetter(rawData);\n                        // 从下一页列表的头部开始取补位数据\n                        if (isArray(cachedListData)) {\n                            pushItem$1(fillingItems, ...splice(cachedListData, 0, len(indexes)));\n                        }\n                        return rawData;\n                    }\n                });\n            }\n            const isLastPageVal = isLastPage.v;\n            const fillingItemsLen = len(fillingItems);\n            if (fillingItemsLen > 0 || isLastPageVal) {\n                // 删除指定索引的数据\n                const newListData = filterItem$1(data.v, (_, index) => !includes(indexes, index));\n                // 翻页模式下，如果是最后一页且全部项被删除了，则往前翻一页\n                if (!append && isLastPageVal && len(newListData) <= 0) {\n                    page.v = pageVal - 1;\n                }\n                else if (fillingItemsLen > 0) {\n                    pushItem$1(newListData, ...fillingItems);\n                }\n                data.v = newListData;\n            }\n            else if (fillingItemsLen <= 0 && !isLastPageVal) {\n                // 移除最后一页数据时，就不需要再刷新了\n                refresh(pageVal);\n            }\n            updateTotal(-len(indexes));\n            // 当前页的缓存同步更新\n            return updateCurrentPageCache();\n        });\n    };\n    /**\n     * 替换一条数据\n     * 如果position传入的是列表项，将替换此列表项，如果列表项未在列表数据中将会抛出错误\n     * @param item 替换项\n     * @param position 替换位置（索引）或列表项\n     */\n    const replace = (item, position) => add2AsyncQueue(async () => {\n        paginationAssert(position !== undefinedValue, 'expect specify the replace position');\n        const index = isNumber(position) ? position : getItemIndex(position);\n        indexAssert(index, data.v);\n        const rawData = [...data.v];\n        splice(rawData, index, 1, item);\n        data.v = rawData;\n        // 当前页的缓存同步更新\n        await updateCurrentPageCache();\n    });\n    /**\n     * 从第${initialPage}页开始重新加载列表，并清空缓存\n     */\n    const reload = () => {\n        promiseThen(invalidatePaginationCache(trueValue), () => {\n            isReset.current = trueValue;\n            page.v === initialPage ? promiseCatch(send(), noop) : (page.v = initialPage);\n        });\n    };\n    // 兼容react，每次缓存最新的操作函数，避免闭包陷阱\n    delegationActions.current = {\n        refresh,\n        insert,\n        remove,\n        replace,\n        reload\n    };\n    /** @Returns */\n    return exposeProvider({\n        ...states,\n        ...objectify([data, page, pageCount, pageSize, total, isLastPage]),\n        fetching: fetchStates.loading,\n        onFetchSuccess: fetchStates.onSuccess,\n        onFetchError: fetchStates.onError,\n        onFetchComplete: fetchStates.onComplete,\n        refresh,\n        insert,\n        remove,\n        replace,\n        reload\n    });\n};\n\nfunction useSQRequest(handler, config = {}) {\n    const { exposeProvider, __referingObj: referingObj } = statesHookHelper(promiseStatesHook());\n    const { middleware = noop } = config;\n    const { c: methodCreateHandler, m: silentMiddleware, b: binders, d: decorateEvent } = createSilentQueueMiddlewares(handler, config);\n    const states = useRequest(methodCreateHandler, {\n        ...config,\n        __referingObj: referingObj,\n        middleware: (ctx, next) => {\n            const silentMidPromise = silentMiddleware(ctx, next);\n            middleware(ctx, () => silentMidPromise);\n            return silentMidPromise;\n        }\n    });\n    decorateEvent(states);\n    return exposeProvider({\n        ...states,\n        ...binders\n    });\n}\n\nconst useAutoRequest = (handler, config = {}) => {\n    let notifiable = trueValue;\n    const { enableFocus = trueValue, enableVisibility = trueValue, enableNetwork = trueValue, pollingTime = 0, throttle = 1000 } = config;\n    const { onMounted, onUnmounted, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());\n    const states = useRequest(handler, {\n        ...config,\n        __referingObj: referingObject\n    });\n    const notify = () => {\n        if (notifiable) {\n            states.send();\n            if (throttle > 0) {\n                notifiable = falseValue;\n                setTimeout(() => {\n                    notifiable = trueValue;\n                }, throttle);\n            }\n        }\n    };\n    let offNetwork = noop;\n    let offFocus = noop;\n    let offVisiblity = noop;\n    let offPolling = noop;\n    onMounted(() => {\n        if (!globalConfigMap.ssr) {\n            offNetwork = enableNetwork ? useAutoRequest.onNetwork(notify, config) : offNetwork;\n            offFocus = enableFocus ? useAutoRequest.onFocus(notify, config) : offFocus;\n            offVisiblity = enableVisibility ? useAutoRequest.onVisibility(notify, config) : offVisiblity;\n            offPolling = pollingTime > 0 ? useAutoRequest.onPolling(notify, config) : offPolling;\n        }\n    });\n    onUnmounted(() => {\n        offNetwork();\n        offFocus();\n        offVisiblity();\n        offPolling();\n    });\n    return states;\n};\nconst on = (type, handler) => {\n    window.addEventListener(type, handler);\n    return () => window.removeEventListener(type, handler);\n};\nuseAutoRequest.onNetwork = notify => on('online', notify);\nuseAutoRequest.onFocus = notify => on('focus', notify);\nuseAutoRequest.onVisibility = notify => {\n    const handle = () => document.visibilityState === 'visible' && notify();\n    return on('visibilitychange', handle);\n};\nuseAutoRequest.onPolling = (notify, config) => {\n    const timer = setInterval(notify, config.pollingTime);\n    return () => clearInterval(timer);\n};\n\nconst hookPrefix$1 = 'useCaptcha';\nconst captchaAssert = createAssert(hookPrefix$1);\nvar useCaptcha = (handler, config = {}) => {\n    const { initialCountdown, middleware } = config;\n    captchaAssert(initialCountdown === undefinedValue || initialCountdown > 0, 'initialCountdown must be greater than 0');\n    const { create, ref, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());\n    const countdown = create(0, 'countdown');\n    const requestReturned = useRequest(handler, {\n        ...config,\n        __referingObj: referingObject,\n        immediate: falseValue,\n        managedStates: objectify([countdown], 's'),\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        middleware: middleware ? (ctx, next) => middleware({ ...ctx, send }, next) : undefinedValue\n    });\n    const timer = ref(undefinedValue);\n    const send = (...args) => newInstance(PromiseCls, (resolve, reject) => {\n        if (countdown.v <= 0) {\n            requestReturned\n                .send(...args)\n                .then(result => {\n                countdown.v = config.initialCountdown || 60;\n                timer.current = setInterval(() => {\n                    countdown.v -= 1;\n                    if (countdown.v <= 0) {\n                        clearInterval(timer.current);\n                    }\n                }, 1000);\n                resolve(result);\n            })\n                .catch(reason => reject(reason));\n        }\n        else {\n            reject(newInstance(AlovaError, hookPrefix$1, 'the countdown is not over yet'));\n        }\n    });\n    return exposeProvider({\n        ...requestReturned,\n        send,\n        ...objectify([countdown])\n    });\n};\n\nconst RestoreEventKey = Symbol('FormRestore');\nconst getStoragedKey = (methodInstance, id) => `alova/form-${id || getMethodInternalKey(methodInstance)}`;\nconst sharedStates = {};\nconst cloneFormData = (form) => {\n    const shallowClone = (value) => (isArray(value) ? [...value] : isPlainObject(value) ? { ...value } : value);\n    return walkObject(shallowClone(form), shallowClone);\n};\nvar useForm = (handler, config = {}) => {\n    const typedSharedStates = sharedStates;\n    const { id, initialForm, store, resetAfterSubmiting, immediate = falseValue, middleware } = config;\n    promiseStatesHook();\n    const { create: $, ref: useFlag$, onMounted: onMounted$, watch: watch$, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());\n    const isStoreObject = isPlainObject(store);\n    const enableStore = isStoreObject ? store.enable : store;\n    // 如果config中的id也有对应的共享状态，则也会返回它\n    // 继续往下执行是为了兼容react的hook执行数不能变的问题，否则会抛出\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\"\n    const sharedState = id ? typedSharedStates[id] : undefinedValue;\n    const form = $(cloneFormData(initialForm), 'form');\n    const methodHandler = handler;\n    const eventManager = createEventManager();\n    // 使用计算属性，避免每次执行此use hook都调用一遍methodHandler\n    const initialMethodInstance = useFlag$(sloughConfig(methodHandler, [form.v]));\n    const storageContext = getContext(initialMethodInstance.current).l2Cache;\n    const storagedKey = getStoragedKey(initialMethodInstance.current, id);\n    const reseting = useFlag$(falseValue);\n    const serializerPerformer = useFlag$(createSerializerPerformer(isStoreObject ? store.serializers : undefinedValue));\n    // 是否由当前hook发起创建的共享状态，发起创建的hook需要返回最新的状态，否则会因为在react中hook被调用，导致发起获得的hook中无法获得最新的状态\n    const isCreateShardState = useFlag$(false);\n    const originalHookProvider = useRequest((...args) => methodHandler(form.v, ...args), {\n        ...config,\n        __referingObj: referingObject,\n        // 中间件函数，也支持subscriberMiddleware\n        middleware: middleware\n            ? (ctx, next) => middleware({\n                ...ctx,\n                // eslint-disable-next-line\n                delegatingActions: { updateForm, reset }\n            }, next)\n            : undefinedValue,\n        // 1. 当需要持久化时，将在数据恢复后触发\n        // 2. 当已有共享状态时，表示之前已有初始化（无论有无立即发起请求），后面的不再自动发起请求，这是为了兼容多表单立即发起请求时，重复发出请求的问题\n        immediate: enableStore || sharedState ? falseValue : immediate\n    });\n    /**\n     * 重置form数据\n     */\n    const reset = () => {\n        reseting.current = trueValue;\n        const clonedFormData = cloneFormData(initialForm);\n        clonedFormData && (form.v = clonedFormData);\n        enableStore && storageContext.remove(storagedKey);\n    };\n    /**\n     * 更新form数据\n     * @param newForm 新表单数据\n     */\n    const updateForm = (newForm) => {\n        form.v = {\n            ...form.v,\n            ...newForm\n        };\n    };\n    const hookProvider = exposeProvider({\n        // 第一个参数固定为form数据\n        ...originalHookProvider,\n        ...objectify([form]),\n        updateForm,\n        reset,\n        // 持久化数据恢复事件绑定\n        onRestore(handler) {\n            eventManager.on(RestoreEventKey, handler);\n        }\n    });\n    // 有id时，才保存到sharedStates中\n    // 在react中，因为更新form后会产生新的form，因此需要每次调用重新保存\n    if (id) {\n        // 还没有共享状态则表示当前hook是创建的hook\n        if (!sharedState) {\n            isCreateShardState.current = trueValue;\n        }\n        // 只保存创建hook的共享状态\n        if (isCreateShardState.current) {\n            typedSharedStates[id] = {\n                hookProvider: hookProvider,\n                config\n            };\n        }\n    }\n    const { send, onSuccess } = hookProvider;\n    onMounted$(() => {\n        // 需要持久化时更新data\n        if (enableStore && !sharedState) {\n            // 获取存储并更新data\n            // 需要在onMounted中调用，否则会导致在react中重复被调用\n            const storagedForm = serializerPerformer.current.deserialize(storageContext.get(storagedKey));\n            // 有草稿数据时，异步恢复数据，否则无法正常绑定onRetore事件\n            if (storagedForm) {\n                form.v = storagedForm;\n                // 触发持久化数据恢复事件\n                eventManager.emit(RestoreEventKey, undefinedValue);\n                enableStore && immediate && send();\n            }\n        }\n    });\n    // 监听变化同步存储，如果是reset触发的则不需要再序列化\n    watch$([form], () => {\n        if (reseting.current || !enableStore) {\n            reseting.current = falseValue;\n            return;\n        }\n        storageContext.set(storagedKey, serializerPerformer.current.serialize(form.v));\n    });\n    // 如果在提交后需要清除数据，则调用reset\n    onSuccess(() => {\n        resetAfterSubmiting && reset();\n    });\n    // 有已保存的sharedState，则返回它\n    // 如果是当前hook创建的共享状态，则返回最新的而非缓存的\n    return sharedState && !isCreateShardState.current ? sharedState.hookProvider : hookProvider;\n};\n\nconst RetryEventKey = Symbol('RetriableRetry');\nconst FailEventKey = Symbol('RetriableFail');\nconst hookPrefix = 'useRetriableRequest';\nconst assert$1 = createAssert(hookPrefix);\nvar useRetriableRequest = (handler, config = {}) => {\n    const { retry = 3, backoff = { delay: 1000 }, middleware = noop } = config;\n    const { ref: useFlag$, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());\n    const eventManager = createEventManager();\n    const retryTimes = useFlag$(0);\n    const stopManuallyError = useFlag$(undefinedValue); // 停止错误对象，在手动触发停止时有值\n    const methodInstanceLastest = useFlag$(undefinedValue);\n    const argsLatest = useFlag$(undefinedValue);\n    const currentLoadingState = useFlag$(falseValue);\n    const requesting = useFlag$(falseValue); // 是否正在请求\n    const retryTimer = useFlag$(undefinedValue);\n    const promiseObj = useFlag$(usePromise());\n    const requestResolved = useFlag$(falseValue);\n    const emitOnFail = (method, args, error) => {\n        if (requestResolved.current) {\n            return;\n        }\n        requestResolved.current = trueValue;\n        // 需要异步触发onFail，让onError和onComplete先触发\n        setTimeoutFn(() => {\n            eventManager.emit(FailEventKey, newInstance((RetriableFailEvent), AlovaEventBase.spawn(method, args), error, retryTimes.current));\n            stopManuallyError.current = undefinedValue;\n            retryTimes.current = 0; // 重置已重试次数\n        });\n    };\n    const nestedHookProvider = useRequest(handler, {\n        ...config,\n        __referingObj: referingObject,\n        middleware(ctx, next) {\n            middleware({\n                ...ctx,\n                delegatingActions: {\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    stop\n                }\n            }, () => promiseResolve(undefinedValue));\n            const { proxyStates, args, send, method, controlLoading } = ctx;\n            const setLoading = (loading = falseValue) => {\n                if (loading !== currentLoadingState.current) {\n                    proxyStates.loading.v = loading;\n                    currentLoadingState.current = loading;\n                }\n            };\n            controlLoading();\n            setLoading(trueValue);\n            methodInstanceLastest.current = method;\n            argsLatest.current = args;\n            requesting.current = trueValue;\n            // init the resolved flag as `false` before first request.\n            if (retryTimes.current === 0) {\n                requestResolved.current = falseValue;\n            }\n            /**\n             * Consider this situation: user call stop() and send another request immediately,\n             * but now the previous request haven't finished. `next()` will raises the branch on completion.\n             *\n             * By using Promise.race(), we can cause the returned promise to be rejected immediately when call `stop()`\n             */\n            return promiseThen(Promise.race([next(), promiseObj.current.promise]), \n            // 请求成功时设置loading为false\n            val => {\n                // retryTimes.current = 0; // 重置已重试次数\n                requesting.current = falseValue;\n                setLoading();\n                return val;\n            }, \n            // 请求失败时触发重试机制\n            error => {\n                // 没有手动触发停止，以及重试次数未到达最大时触发重试\n                if (!stopManuallyError.current && (isNumber(retry) ? retryTimes.current < retry : retry(error, ...args))) {\n                    retryTimes.current += 1;\n                    // 计算重试延迟时间\n                    const retryDelay = delayWithBackoff(backoff, retryTimes.current);\n                    // 延迟对应时间重试\n                    retryTimer.current = setTimeoutFn(() => {\n                        // 如果手动停止了则不再触发重试\n                        promiseCatch(send(...args), noop); // 捕获错误不再往外抛，否则重试时也会抛出错误\n                        // 触发重试事件\n                        eventManager.emit(RetryEventKey, newInstance((RetriableRetryEvent), AlovaEventBase.spawn(method, args), retryTimes.current, retryDelay));\n                    }, retryDelay);\n                }\n                else {\n                    setLoading();\n                    error = stopManuallyError.current || error; // 如果stopManuallyError有值表示是通过stop函数触发停止的\n                    emitOnFail(method, args, error);\n                }\n                requesting.current = falseValue;\n                // 返回reject执行后续的错误流程\n                return promiseReject(error);\n            });\n        }\n    });\n    /**\n     * 停止重试，只在重试期间调用有效\n     * 如果正在请求中，则触发中断请求，让请求错误来抛出错误，否则手动修改状态以及触发onFail\n     * 停止后将立即触发onFail事件\n     */\n    const stop = () => {\n        assert$1(currentLoadingState.current, 'there is no requests being retried');\n        stopManuallyError.current = newInstance(AlovaError, hookPrefix, 'stop retry manually');\n        if (requesting.current) {\n            nestedHookProvider.abort();\n        }\n        else {\n            promiseObj.current.reject(stopManuallyError.current);\n            setTimeout(() => {\n                promiseObj.current = usePromise();\n            });\n            nestedHookProvider.update({ error: stopManuallyError.current, loading: falseValue });\n            currentLoadingState.current = falseValue;\n            clearTimeout(retryTimer.current); // 清除重试定时器\n            // raise fail event at the end, because the above process depends on `stopManuallyError`\n            // emit this event will clears this variable\n            emitOnFail(methodInstanceLastest.current, argsLatest.current, stopManuallyError.current);\n        }\n    };\n    /**\n     * 重试事件绑定\n     * 它们将在重试发起后触发\n     * @param handler 重试事件回调\n     */\n    const onRetry = (handler) => {\n        eventManager.on(RetryEventKey, event => handler(event));\n    };\n    /**\n     * 失败事件绑定\n     * 它们将在不再重试时触发，例如到达最大重试次数时，重试回调返回false时，手动调用stop停止重试时\n     * 而alova的onError事件是在每次请求报错时都将被触发\n     *\n     * 注意：如果没有重试次数时，onError、onComplete和onFail会被同时触发\n     *\n     * @param handler 失败事件回调\n     */\n    const onFail = (handler) => {\n        eventManager.on(FailEventKey, event => handler(event));\n    };\n    return exposeProvider({\n        ...nestedHookProvider,\n        stop,\n        onRetry,\n        onFail\n    });\n};\n\n/**\n * 构建完整的url\n * @param base baseURL\n * @param url 路径\n * @param params url参数\n * @returns 完整的url\n */\nconst buildCompletedURL = (baseURL, url, params) => {\n    // baseURL如果以/结尾，则去掉/\n    baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;\n    // 如果不是/或http协议开头的，则需要添加/\n    url = url.match(/^(\\/|https?:\\/\\/)/) ? url : `/${url}`;\n    const completeURL = baseURL + url;\n    // 将params对象转换为get字符串\n    // 过滤掉值为undefined的\n    const paramsStr = mapItem$1(filterItem$1(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');\n    // 将get参数拼接到url后面，注意url可能已存在参数\n    return paramsStr\n        ? +completeURL.includes('?')\n            ? `${completeURL}&${paramsStr}`\n            : `${completeURL}?${paramsStr}`\n        : completeURL;\n};\n\nconst SSEOpenEventKey = Symbol('SSEOpen');\nconst SSEMessageEventKey = Symbol('SSEMessage');\nconst SSEErrorEventKey = Symbol('SSEError');\nconst assert = createAssert('useSSE');\nconst MessageType = {\n    Open: 'open',\n    Error: 'error',\n    Message: 'message'\n};\nvar useSSE = (handler, config = {}) => {\n    const { initialData, withCredentials, interceptByGlobalResponded = trueValue, \n    /** abortLast = trueValue, */\n    immediate = falseValue } = config;\n    // ! 暂时不支持指定 abortLast\n    const abortLast = trueValue;\n    let { memorize } = promiseStatesHook();\n    memorize !== null && memorize !== void 0 ? memorize : (memorize = $self);\n    const { create, ref, onMounted, onUnmounted, objectify, exposeProvider } = statesHookHelper(promiseStatesHook());\n    const usingArgs = ref([]);\n    const eventSource = ref(undefinedValue);\n    const sendPromiseObject = ref(undefinedValue);\n    const data = create(initialData, 'data');\n    const readyState = create(2 /* SSEHookReadyState.CLOSED */, 'readyState');\n    let methodInstance = getHandlerMethod(handler);\n    let responseUnified;\n    const eventManager = createEventManager();\n    // 储存自定义事件的 useCallback 对象，其中 key 为 eventName\n    const customEventMap = ref(new Map());\n    const onOpen = (handler) => {\n        eventManager.on(SSEOpenEventKey, handler);\n    };\n    const onMessage = (handler) => {\n        eventManager.on(SSEMessageEventKey, handler);\n    };\n    const onError = (handler) => {\n        eventManager.on(SSEErrorEventKey, handler);\n    };\n    const responseSuccessHandler = ref($self);\n    const responseErrorHandler = ref(throwFn);\n    const responseCompleteHandler = ref(noop);\n    /**\n     * 设置响应拦截器，在每次 send 之后都需要调用\n     */\n    const setResponseHandler = (instance) => {\n        // responsed 从 3.0 开始移除\n        const { responded } = getOptions(instance);\n        responseUnified = responded;\n        if (isFn(responseUnified)) {\n            responseSuccessHandler.current = responseUnified;\n        }\n        else if (responseUnified && isPlainObject(responseUnified)) {\n            const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responseUnified;\n            responseSuccessHandler.current = isFn(successHandler) ? successHandler : responseSuccessHandler.current;\n            responseErrorHandler.current = isFn(errorHandler) ? errorHandler : responseErrorHandler.current;\n            responseCompleteHandler.current = isFn(completeHandler) ? completeHandler : responseCompleteHandler.current;\n        }\n    };\n    /**\n     * 处理响应任务，失败时不缓存数据\n     * @param handlerReturns 拦截器返回后的数据\n     * @returns 处理后的response\n     */\n    const handleResponseTask = async (handlerReturns) => {\n        const { headers, transform: transformFn = $self } = getConfig(methodInstance);\n        const returnsData = await handlerReturns;\n        const transformedData = await transformFn(returnsData, (headers || {}));\n        data.v = transformedData;\n        // invalidate cache\n        hitCacheBySource(methodInstance);\n        return transformedData;\n    };\n    /**\n     * 创建 AlovaSSEHook 事件\n     * 具体数据处理流程参考以下链接\n     * @link https://alova.js.org/zh-CN/tutorial/combine-framework/response\n     */\n    const createSSEEvent = async (eventFrom, dataOrError) => {\n        assert(!!eventSource.current, 'EventSource is not initialized');\n        const es = eventSource.current;\n        const baseEvent = new AlovaSSEEvent(AlovaEventBase.spawn(methodInstance, usingArgs.current), es);\n        if (eventFrom === MessageType.Open) {\n            return Promise.resolve(baseEvent);\n        }\n        const globalSuccess = interceptByGlobalResponded ? responseSuccessHandler.current : $self;\n        const globalError = interceptByGlobalResponded ? responseErrorHandler.current : throwFn;\n        const globalFinally = interceptByGlobalResponded ? responseCompleteHandler.current : noop;\n        const p = promiseFinally(promiseThen(dataOrError, res => handleResponseTask(globalSuccess(res, methodInstance)), error => handleResponseTask(globalError(error, methodInstance))), \n        // finally\n        () => {\n            globalFinally(methodInstance);\n        });\n        // 无论如何，函数返回的 Promise 对象一定都会 fulfilled\n        return promiseThen(p, \n        // 得到处理好的数据（transform 之后的数据）\n        res => new AlovaSSEMessageEvent(baseEvent, res), \n        // 有错误\n        error => new AlovaSSEErrorEvent(baseEvent, error));\n    };\n    /**\n     * 根据事件选择需要的触发函数。如果事件无错误则触发传传入的回调函数\n     * @param callback 无错误时触发的回调函数\n     */\n    const sendSSEEvent = (callback) => (event) => {\n        if (event.error === undefinedValue) {\n            return callback(event);\n        }\n        return eventManager.emit(SSEErrorEventKey, event);\n    };\n    // * MARK: EventSource 的事件处理\n    const onCustomEvent = (eventName, callbackHandler) => {\n        var _a;\n        const currentMap = customEventMap.current;\n        if (!currentMap.has(eventName)) {\n            const useCallbackObject = useCallback(callbacks => {\n                var _a;\n                if (callbacks.length === 0) {\n                    (_a = eventSource.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, useCallbackObject[1]);\n                    customEventMap.current.delete(eventName);\n                }\n            });\n            const trigger = useCallbackObject[1];\n            currentMap.set(eventName, useCallbackObject);\n            (_a = eventSource.current) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, event => {\n                promiseThen(createSSEEvent(eventName, Promise.resolve(event.data)), sendSSEEvent(trigger));\n            });\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const [onEvent] = currentMap.get(eventName);\n        return onEvent(callbackHandler);\n    };\n    /**\n     * 取消自定义事件在 useCallback 中的注册\n     */\n    const offCustomEvent = () => {\n        customEventMap.current.forEach(([_1, _2, offTrigger]) => {\n            offTrigger();\n        });\n    };\n    const esOpen = memorize(() => {\n        var _a;\n        // resolve 使用 send() 时返回的 promise\n        readyState.v = 1 /* SSEHookReadyState.OPEN */;\n        promiseThen(createSSEEvent(MessageType.Open, Promise.resolve()), event => eventManager.emit(SSEOpenEventKey, event));\n        // ! 一定要在调用 onOpen 之后 resolve\n        (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.resolve();\n    });\n    const esError = memorize((event) => {\n        var _a, _b;\n        readyState.v = 2 /* SSEHookReadyState.CLOSED */;\n        promiseThen(createSSEEvent(MessageType.Error, Promise.reject((_a = event === null || event === void 0 ? void 0 : event.message) !== null && _a !== void 0 ? _a : 'SSE Error')), sendSSEEvent(event => eventManager.emit(SSEMessageEventKey, event)));\n        (_b = sendPromiseObject.current) === null || _b === void 0 ? void 0 : _b.resolve();\n    });\n    const esMessage = memorize((event) => {\n        promiseThen(createSSEEvent(MessageType.Message, Promise.resolve(event.data)), sendSSEEvent(event => eventManager.emit(SSEMessageEventKey, event)));\n    });\n    /**\n     * 关闭当前 eventSource 的注册\n     */\n    const close = () => {\n        const es = eventSource.current;\n        if (!es) {\n            return;\n        }\n        if (sendPromiseObject.current) {\n            // 如果 close 时 promise 还在\n            sendPromiseObject.current.resolve();\n        }\n        // * MARK: 解绑事件处理\n        es.close();\n        es.removeEventListener(MessageType.Open, esOpen);\n        es.removeEventListener(MessageType.Error, esError);\n        es.removeEventListener(MessageType.Message, esMessage);\n        readyState.v = 2 /* SSEHookReadyState.CLOSED */;\n        // eventSource 关闭后，取消注册所有自定义事件\n        // 否则可能造成内存泄露\n        customEventMap.current.forEach(([_, eventTrigger], eventName) => {\n            es.removeEventListener(eventName, eventTrigger);\n        });\n    };\n    /**\n     * 发送请求并初始化 eventSource\n     */\n    const connect = (...args) => {\n        let es = eventSource.current;\n        let promiseObj = sendPromiseObject.current;\n        if (es && abortLast) {\n            // 当 abortLast === true，关闭之前的连接并重新建立\n            close();\n        }\n        // 设置 send 函数使用的 promise 对象\n        if (!promiseObj) {\n            promiseObj = sendPromiseObject.current = usePromise();\n            // open 后清除 promise 对象\n            promiseObj &&\n                promiseObj.promise.finally(() => {\n                    promiseObj = undefinedValue;\n                });\n        }\n        usingArgs.current = args;\n        methodInstance = getHandlerMethod(handler, args);\n        // 设置响应拦截器\n        setResponseHandler(methodInstance);\n        const { params } = getConfig(methodInstance);\n        const { baseURL, url } = methodInstance;\n        const fullURL = buildCompletedURL(baseURL, url, params);\n        // 建立连接\n        es = new EventSource(fullURL, { withCredentials });\n        eventSource.current = es;\n        readyState.v = 0 /* SSEHookReadyState.CONNECTING */;\n        // * MARK: 注册处理事件\n        // 注册处理事件 open error message\n        es.addEventListener(MessageType.Open, esOpen);\n        es.addEventListener(MessageType.Error, esError);\n        es.addEventListener(MessageType.Message, esMessage);\n        // 以及 自定义事件\n        // 如果在 connect（send）之前就使用了 on 监听，则 customEventMap 里就已经有事件存在\n        customEventMap.current.forEach(([_, eventTrigger], eventName) => {\n            es === null || es === void 0 ? void 0 : es.addEventListener(eventName, event => {\n                promiseThen(createSSEEvent(eventName, Promise.resolve(event.data)), sendSSEEvent(eventTrigger));\n            });\n        });\n        return promiseObj.promise;\n    };\n    onUnmounted(() => {\n        close();\n        // 上面使用 eventSource.removeEventListener 只是断开了 eventSource 和 trigger 的联系\n        // 这里是取消 useCallback 对象中的事件注册\n        eventManager.off(SSEOpenEventKey);\n        eventManager.off(SSEMessageEventKey);\n        eventManager.off(SSEErrorEventKey);\n        offCustomEvent();\n    });\n    // * MARK: 初始化动作\n    onMounted(() => {\n        var _a;\n        if (immediate) {\n            connect();\n            (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.promise.catch(() => { });\n        }\n    });\n    return exposeProvider({\n        send: connect,\n        close,\n        on: onCustomEvent,\n        onMessage,\n        onError,\n        onOpen,\n        eventSource,\n        ...objectify([readyState, data])\n    });\n};\n\nexport { accessAction, actionDelegationMiddleware, bootSilentFactory, createClientTokenAuthentication, createServerTokenAuthentication, dehydrateVData, equals, filterSilentMethods, getSilentMethod, isVData, onBeforeSilentSubmit, onSilentSubmitBoot, onSilentSubmitError, onSilentSubmitFail, onSilentSubmitSuccess, silentQueueMap, stringifyVData, updateState, updateStateEffect, useAutoRequest, useCaptcha, useFetcher, useForm, usePagination, useRequest, useRetriableRequest, useSQRequest, useSSE, useSerialRequest, useSerialWatcher, useWatcher };\n"],
  "mappings": "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",
  "names": ["assert", "getHandlerMethod", "pushItem", "mapItem", "filterItem", "uuid", "frontStates", "methodInstance", "data", "error", "debounce", "customSerializers", "Null", "Undefined", "key", "queueName", "queue", "silentQueueMap", "handler", "config", "page", "states", "force", "rawData", "decorateEvent", "serializerPerformer", "_a", "event"]
}
