{
  "version": 3,
  "sources": ["../../../../node_modules/@alova/shared/dist/assert.js", "../../../../node_modules/alova/dist/alova.esm.js"],
  "sourcesContent": ["/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nconst undefStr = 'undefined';\n// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断\n// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用\n// 因此使用服务端独有的 process.cwd 函数作为判断依据\ntypeof window === undefStr &&\n    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);\n\n/**\n * 创建类实例\n * @param Cls 构造函数\n * @param args 构造函数参数\n * @returns 类实例\n */\nconst newInstance = (Cls, ...args) => new Cls(...args);\n\n/**\n * alova错误类\n */\nclass AlovaError extends Error {\n    constructor(prefix, message, errorCode) {\n        super(message + (errorCode ? `\\n\\nFor detailed: https://alova.js.org/error#${errorCode}` : ''));\n        this.name = `[alova${prefix ? `/${prefix}` : ''}]`;\n    }\n}\n/**\n * 自定义断言函数，表达式为false时抛出错误\n * 当传入了errorCode时，将提供链接到错误文档，引导用户改正\n * @param expression 判断表达式，true或false\n * @param message 断言消息\n */\nconst createAssert = (prefix = '') => (expression, message, errorCode) => {\n    if (!expression) {\n        throw newInstance(AlovaError, prefix, message, errorCode);\n    }\n};\n\nexport { AlovaError, createAssert };\n", "/**\n  * alova 3.0.16 (https://alova.js.org)\n  * Document https://alova.js.org\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nimport { getTime, buildNamespacedCacheKey, instanceOf, newInstance, getContext, objAssign, getMethodInternalKey, getLocalCacheConfigParam, isFn, getConfig, getOptions, isPlainObject, sloughFunction, noop, $self, isSpecialRequestBody, getContextOptions, key, isString } from '@alova/shared/function';\nimport { defaultIsSSR, STORAGE_RESTORE, len, filterItem as filterItem$1, undefinedValue, forEach, RegExpCls, pushItem as pushItem$1, mapItem as mapItem$1, objectKeys, PromiseCls, deleteAttr, isArray, MEMORY, promiseThen, trueValue, falseValue, promiseFinally, promiseReject, promiseCatch, JSONStringify, JSONParse } from '@alova/shared/vars';\nimport { createAssert } from '@alova/shared/assert';\n\nlet globalConfigMap = {\n    autoHitCache: 'global',\n    ssr: defaultIsSSR\n};\n/**\n * Set global configuration\n * @param config\n */\nvar globalConfig = (config) => {\n    globalConfigMap = {\n        ...globalConfigMap,\n        ...config\n    };\n};\n\nconst titleStyle = 'color: black; font-size: 12px; font-weight: bolder';\n/**\n * 默认cacheLogger函数\n */\nvar defaultCacheLogger = (response, methodInstance, cacheMode, tag) => {\n    const cole = console;\n    // eslint-disable-next-line\n    const log = (...args) => console.log(...args);\n    const { url } = methodInstance;\n    const isRestoreMode = cacheMode === STORAGE_RESTORE;\n    const hdStyle = '\\x1B[42m%s\\x1B[49m';\n    const labelStyle = '\\x1B[32m%s\\x1B[39m';\n    const startSep = ` [HitCache]${url} `;\n    const endSepFn = () => Array(len(startSep) + 1).join('^');\n    if (globalConfigMap.ssr) {\n        log(hdStyle, startSep);\n        log(labelStyle, ' Cache ', response);\n        log(labelStyle, ' Mode  ', cacheMode);\n        isRestoreMode && log(labelStyle, ' Tag   ', tag);\n        log(labelStyle, endSepFn());\n    }\n    else {\n        cole.groupCollapsed\n            ? cole.groupCollapsed('%cHitCache', 'padding: 2px 6px; background: #c4fcd3; color: #53b56d;', url)\n            : log(hdStyle, startSep);\n        log('%c[Cache]', titleStyle, response);\n        log('%c[Mode]', titleStyle, cacheMode);\n        isRestoreMode && log('%c[Tag]', titleStyle, tag);\n        log('%c[Method]', titleStyle, methodInstance);\n        cole.groupEnd ? cole.groupEnd() : log(labelStyle, endSepFn());\n    }\n};\n\nconst hitSourceStringCacheKey = (key) => `hss.${key}`;\nconst hitSourceRegexpPrefix = 'hsr.';\nconst hitSourceRegexpCacheKey = (regexpStr) => hitSourceRegexpPrefix + regexpStr;\nconst unifiedHitSourceRegexpCacheKey = '$$hsrs';\nconst regexpSourceFlagSeparator = '__$<>$__';\nconst addItem = (obj, item) => {\n    obj[item] = 0;\n};\n/**\n * set or update cache\n * @param namespace 命名空间\n * @param key 存储的key\n * @param response 存储的响应内容\n * @param expireTimestamp 过期时间点的时间戳表示\n * @param storage 存储对象\n * @param tag 存储标签，用于区分不同的存储标记\n */\nconst setWithCacheAdapter = async (namespace, key, data, expireTimestamp, cacheAdapter, hitSource, tag) => {\n    // not to cache if expireTimestamp is less than current timestamp\n    if (expireTimestamp > getTime() && data) {\n        const methodCacheKey = buildNamespacedCacheKey(namespace, key);\n        await cacheAdapter.set(methodCacheKey, filterItem$1([data, expireTimestamp === Infinity ? undefinedValue : expireTimestamp, tag], Boolean));\n        // save the relationship between this method and its hitSources.\n        // cache structure is like this:\n        /*\n          {\n            \"$a.[namespace][methodKey]\": [cache data],\n            ...\n            \"hss.[sourceMethodKey]\": \"{\n              [targetMethodKey1]: 0,\n              [targetMethodKey2]: 0,\n              ...\n            }\",\n            \"hss.[sourceMethodName]\": \"{\n              [targetMethodKey3]: 0,\n              [targetMethodKey4]: 0,\n              ...\n            }\",\n            \"hsr.[sourceMethodNameRegexpSource]\": \"{\n              [targetMethodKey5]: 0,\n              [targetMethodKey6]: 0,\n              ...\n            }\",\n            \"hsr.regexp1\": [\"hss.key1\", \"hss.key2\"],\n            \"hsr.regexp2\": [\"hss.key1\", \"hss.key2\"]\n          }\n        */\n        if (hitSource) {\n            // filter repeat items and categorize the regexp, to prevent unnecessary cost of IO\n            const hitSourceKeys = {};\n            const hitSourceRegexpSources = [];\n            forEach(hitSource, sourceItem => {\n                const isRegexp = instanceOf(sourceItem, RegExpCls);\n                const targetHitSourceKey = isRegexp\n                    ? sourceItem.source + (sourceItem.flags ? regexpSourceFlagSeparator + sourceItem.flags : '')\n                    : sourceItem;\n                if (targetHitSourceKey) {\n                    if (isRegexp && !hitSourceKeys[targetHitSourceKey]) {\n                        pushItem$1(hitSourceRegexpSources, targetHitSourceKey);\n                    }\n                    addItem(hitSourceKeys, isRegexp ? hitSourceRegexpCacheKey(targetHitSourceKey) : hitSourceStringCacheKey(targetHitSourceKey));\n                }\n            });\n            // save the relationship. Minimize IO as much as possible\n            const promises = mapItem$1(objectKeys(hitSourceKeys), async (hitSourceKey) => {\n                // filter the empty strings.\n                const targetMethodKeys = (await cacheAdapter.get(hitSourceKey)) || {};\n                addItem(targetMethodKeys, methodCacheKey);\n                await cacheAdapter.set(hitSourceKey, targetMethodKeys);\n            });\n            const saveRegexp = async () => {\n                // save the regexp source if regexp exists.\n                if (len(hitSourceRegexpSources)) {\n                    const regexpList = (await cacheAdapter.get(unifiedHitSourceRegexpCacheKey)) || [];\n                    // TODO: hitSourceRegexpSources 需要去重\n                    pushItem$1(regexpList, ...hitSourceRegexpSources);\n                    await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, regexpList);\n                }\n            };\n            // parallel executing all async tasks.\n            await PromiseCls.all([...promises, saveRegexp()]);\n        }\n    }\n};\n/**\n * 删除存储的响应数据\n * @param namespace 命名空间\n * @param key 存储的key\n * @param storage 存储对象\n */\nconst removeWithCacheAdapter = async (namespace, key, cacheAdapter) => {\n    const methodStoreKey = buildNamespacedCacheKey(namespace, key);\n    await cacheAdapter.remove(methodStoreKey);\n};\n/**\n * 获取存储的响应数据\n * @param namespace 命名空间\n * @param key 存储的key\n * @param storage 存储对象\n * @param tag 存储标签，标记改变了数据将会失效\n */\nconst getRawWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {\n    const storagedData = await cacheAdapter.get(buildNamespacedCacheKey(namespace, key));\n    if (storagedData) {\n        // eslint-disable-next-line\n        const [_, expireTimestamp, storedTag] = storagedData;\n        // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期\n        if (storedTag === tag && (!expireTimestamp || expireTimestamp > getTime())) {\n            return storagedData;\n        }\n        // 如果过期，则删除缓存\n        await removeWithCacheAdapter(namespace, key, cacheAdapter);\n    }\n};\n/**\n * 获取存储的响应数据\n * @param namespace 命名空间\n * @param key 存储的key\n * @param storage 存储对象\n * @param tag 存储标签，标记改变了数据将会失效\n */\nconst getWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {\n    const rawData = await getRawWithCacheAdapter(namespace, key, cacheAdapter, tag);\n    return rawData ? rawData[0] : undefinedValue;\n};\n/**\n * clear all cached data\n */\nconst clearWithCacheAdapter = async (cacheAdapters) => PromiseCls.all(cacheAdapters.map(cacheAdapter => cacheAdapter.clear()));\n/**\n * query and delete target cache with key and name of source method instance.\n * @param sourceKey source method instance key\n * @param sourceName source method instance name\n * @param cacheAdapter cache adapter\n */\nconst hitTargetCacheWithCacheAdapter = async (sourceKey, sourceName, cacheAdapter) => {\n    const sourceNameStr = `${sourceName}`;\n    // map that recording the source key and target method keys.\n    const sourceTargetKeyMap = {};\n    // get hit key by method key.\n    const hitSourceKey = hitSourceStringCacheKey(sourceKey);\n    sourceTargetKeyMap[hitSourceKey] = await cacheAdapter.get(hitSourceKey);\n    let unifiedHitSourceRegexpChannel;\n    if (sourceName) {\n        const hitSourceName = hitSourceStringCacheKey(sourceNameStr);\n        // get hit key by method name if it is exists.\n        sourceTargetKeyMap[hitSourceName] = await cacheAdapter.get(hitSourceName);\n        // match regexped key by source method name and get hit key by method name.\n        unifiedHitSourceRegexpChannel = await cacheAdapter.get(unifiedHitSourceRegexpCacheKey);\n        const matchedRegexpStrings = [];\n        if (unifiedHitSourceRegexpChannel && len(unifiedHitSourceRegexpChannel)) {\n            forEach(unifiedHitSourceRegexpChannel, regexpStr => {\n                const [source, flag] = regexpStr.split(regexpSourceFlagSeparator);\n                if (newInstance(RegExpCls, source, flag).test(sourceNameStr)) {\n                    pushItem$1(matchedRegexpStrings, regexpStr);\n                }\n            });\n            // parallel get hit key by matched regexps.\n            await PromiseCls.all(mapItem$1(matchedRegexpStrings, async (regexpString) => {\n                const hitSourceRegexpString = hitSourceRegexpCacheKey(regexpString);\n                sourceTargetKeyMap[hitSourceRegexpString] = await cacheAdapter.get(hitSourceRegexpString);\n            }));\n        }\n    }\n    const removeWithTargetKey = async (targetKey) => {\n        try {\n            await cacheAdapter.remove(targetKey);\n            // loop sourceTargetKeyMap and remove this key to prevent unnecessary cost of IO.\n            for (const sourceKey in sourceTargetKeyMap) {\n                const targetKeys = sourceTargetKeyMap[sourceKey];\n                if (targetKeys) {\n                    deleteAttr(targetKeys, targetKey);\n                }\n            }\n        }\n        catch (error) {\n            // the try-catch is used to prevent throwing error, cause throwing error in `Promise.all` below.\n        }\n    };\n    // now let's start to delete target caches.\n    // and filter the finished keys.\n    const accessedKeys = {};\n    await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {\n        const targetKeys = sourceTargetKeyMap[sourceKey];\n        if (targetKeys) {\n            const removingPromises = [];\n            for (const key in targetKeys) {\n                if (!accessedKeys[key]) {\n                    addItem(accessedKeys, key);\n                    pushItem$1(removingPromises, removeWithTargetKey(key));\n                }\n            }\n            await PromiseCls.all(removingPromises);\n        }\n    }));\n    // update source key if there is still has keys.\n    // remove source key if its keys is empty.\n    const unifiedHitSourceRegexpChannelLen = len(unifiedHitSourceRegexpChannel || []);\n    await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {\n        const targetKeys = sourceTargetKeyMap[sourceKey];\n        if (targetKeys) {\n            if (len(objectKeys(targetKeys))) {\n                await cacheAdapter.set(sourceKey, targetKeys);\n            }\n            else {\n                await cacheAdapter.remove(sourceKey);\n                // if this is a regexped key, need to remove it from unified regexp channel.\n                if (sourceKey.includes(hitSourceRegexpPrefix) && unifiedHitSourceRegexpChannel) {\n                    unifiedHitSourceRegexpChannel = filterItem$1(unifiedHitSourceRegexpChannel, rawRegexpStr => hitSourceRegexpCacheKey(rawRegexpStr) !== sourceKey);\n                }\n            }\n        }\n    }));\n    // update unified hit source regexp channel if its length was changed.\n    if (unifiedHitSourceRegexpChannelLen !== len(unifiedHitSourceRegexpChannel || [])) {\n        await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, unifiedHitSourceRegexpChannel);\n    }\n};\n\nvar cloneMethod = (methodInstance) => {\n    const { data, config } = methodInstance;\n    const newConfig = { ...config };\n    const { headers = {}, params = {} } = newConfig;\n    const ctx = getContext(methodInstance);\n    newConfig.headers = { ...headers };\n    newConfig.params = { ...params };\n    const newMethod = newInstance((Method), methodInstance.type, ctx, methodInstance.url, newConfig, data);\n    return objAssign(newMethod, {\n        ...methodInstance,\n        config: newConfig\n    });\n};\n\n/*\n * 以下三个函数中的matcher为Method实例匹配器，它分为3种情况：\n * 1. 如果matcher为Method实例，则清空该Method实例缓存\n * 2. 如果matcher为字符串或正则，则清空所有符合条件的Method实例缓存\n * 3. 如果未传入matcher，则会清空所有缓存\n */\n/**\n * 查询缓存\n * @param matcher Method实例匹配器\n * @returns 缓存数据，未查到时返回undefined\n */\nconst queryCache = async (matcher, { policy = 'all' } = {}) => {\n    // if key exists, that means it's a method instance.\n    if (matcher && matcher.key) {\n        const { id, l1Cache, l2Cache } = getContext(matcher);\n        const methodKey = getMethodInternalKey(matcher);\n        const { f: cacheFor, c: controlled, s: store, e: expireMilliseconds, t: tag } = getLocalCacheConfigParam(matcher);\n        // if it's controlled cache, it will return the result of cacheFor function.\n        if (controlled) {\n            return cacheFor();\n        }\n        let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;\n        if (policy === 'l2') {\n            cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);\n        }\n        else if (policy === 'all' && !cachedData) {\n            if (store && expireMilliseconds(STORAGE_RESTORE) > getTime()) {\n                cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);\n            }\n        }\n        return cachedData;\n    }\n};\n/**\n * 手动设置缓存响应数据，如果对应的methodInstance设置了持久化存储，则还会去检出持久化存储中的缓存\n * @param matcher Method实例匹配器\n * @param data 缓存数据\n */\nconst setCache = async (matcher, dataOrUpdater, { policy = 'all' } = {}) => {\n    const methodInstances = isArray(matcher) ? matcher : [matcher];\n    const batchPromises = methodInstances.map(async (methodInstance) => {\n        const { hitSource } = methodInstance;\n        const { id, l1Cache, l2Cache } = getContext(methodInstance);\n        const methodKey = getMethodInternalKey(methodInstance);\n        const { e: expireMilliseconds, s: toStore, t: tag, c: controlled } = getLocalCacheConfigParam(methodInstance);\n        // don't set cache when it's controlled cache.\n        if (controlled) {\n            return;\n        }\n        let data = dataOrUpdater;\n        if (isFn(dataOrUpdater)) {\n            let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;\n            if (policy === 'l2' ||\n                (policy === 'all' && !cachedData && toStore && expireMilliseconds(STORAGE_RESTORE) > getTime())) {\n                cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);\n            }\n            data = dataOrUpdater(cachedData);\n            if (data === undefinedValue) {\n                return;\n            }\n        }\n        return PromiseCls.all([\n            policy !== 'l2' && setWithCacheAdapter(id, methodKey, data, expireMilliseconds(MEMORY), l1Cache, hitSource),\n            policy === 'l2' || (policy === 'all' && toStore)\n                ? setWithCacheAdapter(id, methodKey, data, expireMilliseconds(STORAGE_RESTORE), l2Cache, hitSource, tag)\n                : undefinedValue\n        ]);\n    });\n    return PromiseCls.all(batchPromises);\n};\n/**\n * 失效缓存\n * @param matcher Method实例匹配器\n */\nconst invalidateCache = async (matcher) => {\n    if (!matcher) {\n        await PromiseCls.all([clearWithCacheAdapter(usingL1CacheAdapters), clearWithCacheAdapter(usingL2CacheAdapters)]);\n        return;\n    }\n    const methodInstances = isArray(matcher) ? matcher : [matcher];\n    const batchPromises = methodInstances.map(methodInstance => {\n        const { id, l1Cache, l2Cache } = getContext(methodInstance);\n        const { c: controlled } = getLocalCacheConfigParam(methodInstance);\n        // don't invalidate cache when it's controlled cache.\n        if (controlled) {\n            return;\n        }\n        const methodKey = getMethodInternalKey(methodInstance);\n        return PromiseCls.all([\n            removeWithCacheAdapter(id, methodKey, l1Cache),\n            removeWithCacheAdapter(id, methodKey, l2Cache)\n        ]);\n    });\n    await PromiseCls.all(batchPromises);\n};\n/**\n * hit(invalidate) target caches by source method\n * this is the implementation of auto invalidate cache\n * @param sourceMethod source method instance\n */\nconst hitCacheBySource = async (sourceMethod) => {\n    // 查找hit target cache，让它的缓存失效\n    // 通过全局配置`autoHitCache`来控制自动缓存失效范围\n    const { autoHitCache } = globalConfigMap;\n    const { l1Cache, l2Cache } = getContext(sourceMethod);\n    const sourceKey = getMethodInternalKey(sourceMethod);\n    const { name: sourceName } = getConfig(sourceMethod);\n    const cacheAdaptersInvolved = {\n        global: [...usingL1CacheAdapters, ...usingL2CacheAdapters],\n        self: [l1Cache, l2Cache],\n        close: []\n    }[autoHitCache];\n    if (cacheAdaptersInvolved && len(cacheAdaptersInvolved)) {\n        await PromiseCls.all(mapItem$1(cacheAdaptersInvolved, involvedCacheAdapter => hitTargetCacheWithCacheAdapter(sourceKey, sourceName, involvedCacheAdapter)));\n    }\n};\n\nconst adapterReturnMap = {};\n/**\n * 构建完整的url\n * @param base baseURL\n * @param url 路径\n * @param params url参数\n * @returns 完整的url\n */\nconst buildCompletedURL = (baseURL, url, params) => {\n    // baseURL如果以/结尾，则去掉/\n    baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;\n    // 如果不是/或http协议开头的，则需要添加/\n    // Compatible with some RESTful usage\n    // fix: https://github.com/alovajs/alova/issues/382\n    if (url !== '') {\n        url = url.match(/^(\\/|https?:\\/\\/)/) ? url : `/${url}`;\n    }\n    const completeURL = baseURL + url;\n    // 将params对象转换为get字符串\n    // 过滤掉值为undefined的\n    const paramsStr = mapItem$1(filterItem$1(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');\n    // 将get参数拼接到url后面，注意url可能已存在参数\n    return paramsStr\n        ? +completeURL.includes('?')\n            ? `${completeURL}&${paramsStr}`\n            : `${completeURL}?${paramsStr}`\n        : completeURL;\n};\n/**\n * 实际的请求函数\n * @param method 请求方法对象\n * @param forceRequest 忽略缓存\n * @returns 响应数据\n */\nfunction sendRequest(methodInstance, forceRequest) {\n    let fromCache = trueValue;\n    let requestAdapterCtrlsPromiseResolveFn;\n    const requestAdapterCtrlsPromise = newInstance(PromiseCls, resolve => {\n        requestAdapterCtrlsPromiseResolveFn = resolve;\n    });\n    const response = async () => {\n        const { beforeRequest = noop, responded, requestAdapter, cacheLogger } = getOptions(methodInstance);\n        const methodKey = getMethodInternalKey(methodInstance);\n        const { s: toStorage, t: tag, m: cacheMode, e: expireMilliseconds } = getLocalCacheConfigParam(methodInstance);\n        const { id, l1Cache, l2Cache, snapshots } = getContext(methodInstance);\n        // 获取受控缓存或非受控缓存\n        const { cacheFor } = getConfig(methodInstance);\n        const { hitSource: methodHitSource } = methodInstance;\n        // 如果当前method设置了受控缓存，则看是否有自定义的数据\n        let cachedResponse = await (isFn(cacheFor)\n            ? cacheFor()\n            : // 如果是强制请求的，则跳过从缓存中获取的步骤\n                // 否则判断是否使用缓存数据\n                forceRequest\n                    ? undefinedValue\n                    : getWithCacheAdapter(id, methodKey, l1Cache));\n        // 如果是STORAGE_RESTORE模式，且缓存没有数据时，则需要将持久化数据恢复到缓存中，过期时间要使用缓存的\n        if (cacheMode === STORAGE_RESTORE && !cachedResponse) {\n            const rawL2CacheData = await getRawWithCacheAdapter(id, methodKey, l2Cache, tag);\n            if (rawL2CacheData) {\n                const [l2Response, l2ExpireMilliseconds] = rawL2CacheData;\n                await setWithCacheAdapter(id, methodKey, l2Response, l2ExpireMilliseconds, l1Cache, methodHitSource);\n                cachedResponse = l2Response;\n            }\n        }\n        // 克隆method作为参数传给beforeRequest，防止多次使用原method实例请求时产生副作用\n        // 放在` let cachedResponse = await ...`之后，解决在method.send中先赋值promise给method实例的问题，否则在clonedMethod中promise为undefined\n        const clonedMethod = cloneMethod(methodInstance);\n        // 发送请求前调用钩子函数\n        // beforeRequest支持同步函数和异步函数\n        await beforeRequest(clonedMethod);\n        const { baseURL, url: newUrl, type, data } = clonedMethod;\n        const { params = {}, headers = {}, transform = $self, shareRequest } = getConfig(clonedMethod);\n        const namespacedAdapterReturnMap = (adapterReturnMap[id] = adapterReturnMap[id] || {});\n        let requestAdapterCtrls = namespacedAdapterReturnMap[methodKey];\n        let responseSuccessHandler = $self;\n        let responseErrorHandler = undefinedValue;\n        let responseCompleteHandler = noop;\n        // uniform handler of onSuccess, onError, onComplete\n        if (isFn(responded)) {\n            responseSuccessHandler = responded;\n        }\n        else if (isPlainObject(responded)) {\n            const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responded;\n            responseSuccessHandler = isFn(successHandler) ? successHandler : responseSuccessHandler;\n            responseErrorHandler = isFn(errorHandler) ? errorHandler : responseErrorHandler;\n            responseCompleteHandler = isFn(completeHandler) ? completeHandler : responseCompleteHandler;\n        }\n        // 如果没有缓存则发起请求\n        if (cachedResponse !== undefinedValue) {\n            requestAdapterCtrlsPromiseResolveFn(); // 遇到缓存将不传入ctrls\n            // 打印缓存日志\n            sloughFunction(cacheLogger, defaultCacheLogger)(cachedResponse, clonedMethod, cacheMode, tag);\n            responseCompleteHandler(clonedMethod);\n            return cachedResponse;\n        }\n        fromCache = falseValue;\n        if (!shareRequest || !requestAdapterCtrls) {\n            // 请求数据\n            const ctrls = requestAdapter({\n                url: buildCompletedURL(baseURL, newUrl, params),\n                type,\n                data,\n                headers\n            }, clonedMethod);\n            requestAdapterCtrls = namespacedAdapterReturnMap[methodKey] = ctrls;\n        }\n        // 将requestAdapterCtrls传到promise中供onDownload、onUpload及abort中使用\n        requestAdapterCtrlsPromiseResolveFn(requestAdapterCtrls);\n        /**\n         * 处理响应任务，失败时不缓存数据\n         * @param responsePromise 响应promise实例\n         * @param responseHeaders 请求头\n         * @param callInSuccess 是否在成功回调中调用\n         * @returns 处理后的response\n         */\n        const handleResponseTask = async (handlerReturns, responseHeaders, callInSuccess = trueValue) => {\n            const responseData = await handlerReturns;\n            const transformedData = await transform(responseData, responseHeaders || {});\n            snapshots.save(methodInstance);\n            // 即使缓存操作失败，也正常返回响应结构，避免因缓存操作问题导致请求错误\n            // 缓存操作结果，可通过`cacheAdapter.emitter.on('success' | 'fail', event => {})`监听获取\n            try {\n                // 自动失效缓存\n                await hitCacheBySource(clonedMethod);\n            }\n            catch (error) { }\n            // 当requestBody为特殊数据时不保存缓存\n            // 原因1：特殊数据一般是提交特殊数据，需要和服务端交互\n            // 原因2：特殊数据不便于生成缓存key\n            const requestBody = clonedMethod.data;\n            const toCache = !requestBody || !isSpecialRequestBody(requestBody);\n            // 使用响应后最新的过期时间来缓存数据，避免因响应时间过长导致过期时间流失的问题\n            if (toCache && callInSuccess) {\n                try {\n                    await PromiseCls.all([\n                        setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(MEMORY), l1Cache, methodHitSource),\n                        toStorage &&\n                            setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(STORAGE_RESTORE), l2Cache, methodHitSource, tag)\n                    ]);\n                }\n                catch (error) { }\n            }\n            return transformedData;\n        };\n        return promiseFinally(promiseThen(PromiseCls.all([requestAdapterCtrls.response(), requestAdapterCtrls.headers()]), ([rawResponse, rawHeaders]) => {\n            // 无论请求成功、失败，都需要首先移除共享的请求\n            deleteAttr(namespacedAdapterReturnMap, methodKey);\n            return handleResponseTask(responseSuccessHandler(rawResponse, clonedMethod), rawHeaders);\n        }, (error) => {\n            // 无论请求成功、失败，都需要首先移除共享的请求\n            deleteAttr(namespacedAdapterReturnMap, methodKey);\n            return isFn(responseErrorHandler)\n                ? // 响应错误时，如果未抛出错误也将会处理响应成功的流程，但不缓存数据\n                    handleResponseTask(responseErrorHandler(error, clonedMethod), undefinedValue, falseValue)\n                : promiseReject(error);\n        }), () => {\n            responseCompleteHandler(clonedMethod);\n        });\n    };\n    return {\n        // 请求中断函数\n        abort: () => {\n            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.abort());\n        },\n        onDownload: (handler) => {\n            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onDownload && requestAdapterCtrls.onDownload(handler));\n        },\n        onUpload: (handler) => {\n            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onUpload && requestAdapterCtrls.onUpload(handler));\n        },\n        response,\n        fromCache: () => fromCache\n    };\n}\n\nconst offEventCallback = (offHandler, handlers) => () => {\n    const index = handlers.indexOf(offHandler);\n    index >= 0 && handlers.splice(index, 1);\n};\nclass Method {\n    constructor(type, context, url, config, data) {\n        this.dhs = [];\n        this.uhs = [];\n        this.fromCache = undefinedValue;\n        const abortRequest = () => {\n            abortRequest.a();\n        };\n        abortRequest.a = noop;\n        const instance = this;\n        const contextOptions = getContextOptions(context);\n        instance.abort = abortRequest;\n        instance.baseURL = contextOptions.baseURL || '';\n        instance.url = url;\n        instance.type = type;\n        instance.context = context;\n        // 将请求相关的全局配置合并到Method对象中\n        const contextConcatConfig = {};\n        const mergedLocalCacheKey = 'cacheFor';\n        const globalLocalCache = isPlainObject(contextOptions[mergedLocalCacheKey])\n            ? contextOptions[mergedLocalCacheKey][type]\n            : undefinedValue;\n        const hitSource = config && config.hitSource;\n        // 合并参数\n        forEach(['timeout', 'shareRequest'], mergedKey => {\n            if (contextOptions[mergedKey] !== undefinedValue) {\n                contextConcatConfig[mergedKey] = contextOptions[mergedKey];\n            }\n        });\n        // 合并localCache\n        if (globalLocalCache !== undefinedValue) {\n            contextConcatConfig[mergedLocalCacheKey] = globalLocalCache;\n        }\n        // 将hitSource统一处理成数组，且当有method实例时将它们转换为methodKey\n        if (hitSource) {\n            instance.hitSource = mapItem$1(isArray(hitSource) ? hitSource : [hitSource], sourceItem => instanceOf(sourceItem, Method) ? getMethodInternalKey(sourceItem) : sourceItem);\n            deleteAttr(config, 'hitSource');\n        }\n        instance.config = {\n            ...contextConcatConfig,\n            headers: {},\n            params: {},\n            ...(config || {})\n        };\n        instance.data = data;\n        instance.meta = config ? config.meta : instance.meta;\n        // 在外部需要使用原始的key，而不是实时生成key\n        // 原因是，method的参数可能传入引用类型值，但引用类型值在外部改变时，实时生成的key也随之改变，因此使用最开始的key更准确\n        instance.key = instance.generateKey();\n    }\n    /**\n     * 绑定下载进度回调函数\n     * @param progressHandler 下载进度回调函数\n     * @version 2.17.0\n     * @return 解绑函数\n     */\n    onDownload(downloadHandler) {\n        pushItem$1(this.dhs, downloadHandler);\n        return offEventCallback(downloadHandler, this.dhs);\n    }\n    /**\n     * 绑定上传进度回调函数\n     * @param progressHandler 上传进度回调函数\n     * @version 2.17.0\n     * @return 解绑函数\n     */\n    onUpload(uploadHandler) {\n        pushItem$1(this.uhs, uploadHandler);\n        return offEventCallback(uploadHandler, this.uhs);\n    }\n    /**\n     * 通过method实例发送请求，返回promise对象\n     */\n    send(forceRequest = falseValue) {\n        const instance = this;\n        const { response, onDownload, onUpload, abort, fromCache } = sendRequest(instance, forceRequest);\n        len(instance.dhs) > 0 &&\n            onDownload((loaded, total) => forEach(instance.dhs, handler => handler({ loaded, total })));\n        len(instance.uhs) > 0 && onUpload((loaded, total) => forEach(instance.uhs, handler => handler({ loaded, total })));\n        // 每次请求时将中断函数绑定给method实例，使用者也可通过methodInstance.abort()来中断当前请求\n        instance.abort.a = abort;\n        instance.fromCache = undefinedValue;\n        instance.promise = promiseThen(response(), r => {\n            instance.fromCache = fromCache();\n            return r;\n        });\n        return instance.promise;\n    }\n    /**\n     * 设置方法名称，如果已有名称将被覆盖\n     * @param name 方法名称\n     */\n    setName(name) {\n        getConfig(this).name = name;\n    }\n    generateKey() {\n        return key(this);\n    }\n    /**\n     * 绑定resolve和/或reject Promise的callback\n     * @param onfulfilled resolve Promise时要执行的回调\n     * @param onrejected 当Promise被reject时要执行的回调\n     * @returns 返回一个Promise，用于执行任何回调\n     */\n    then(onfulfilled, onrejected) {\n        return promiseThen(this.send(), onfulfilled, onrejected);\n    }\n    /**\n     * 绑定一个仅用于reject Promise的回调\n     * @param onrejected 当Promise被reject时要执行的回调\n     * @returns 返回一个完成回调的Promise\n     */\n    catch(onrejected) {\n        return promiseCatch(this.send(), onrejected);\n    }\n    /**\n     * 绑定一个回调，该回调在Promise结算（resolve或reject）时调用\n     * @param onfinally Promise结算（resolve或reject）时执行的回调。\n     * @return 返回一个完成回调的Promise。\n     */\n    finally(onfinally) {\n        return promiseFinally(this.send(), onfinally);\n    }\n}\n\n// import { get } from '@alova/shared';\n/**\n * 自定义断言函数，表达式为false时抛出错误\n * @param expression 判断表达式，true或false\n * @param msg 断言消息\n */\nconst myAssert = createAssert();\n\n/**\n  * @alova/shared 1.0.5 (undefined)\n  * Document undefined\n  * Copyright 2024 Scott Hu. All Rights Reserved\n  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)\n*/\n\nconst undefStr = 'undefined';\nconst pushItem = (ary, ...item) => ary.push(...item);\nconst mapItem = (ary, callbackfn) => ary.map(callbackfn);\nconst filterItem = (ary, predicate) => ary.filter(predicate);\n// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断\n// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用\n// 因此使用服务端独有的 process.cwd 函数作为判断依据\ntypeof window === undefStr &&\n    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);\n\nconst createEventManager = () => {\n    const eventMap = {};\n    return {\n        eventMap,\n        on(type, handler) {\n            const eventTypeItem = (eventMap[type] = eventMap[type] || []);\n            pushItem(eventTypeItem, handler);\n            // return the off function\n            return () => {\n                eventMap[type] = filterItem(eventTypeItem, item => item !== handler);\n            };\n        },\n        off(type, handler) {\n            const handlers = eventMap[type];\n            if (!handlers) {\n                return;\n            }\n            if (handler) {\n                const index = handlers.indexOf(handler);\n                index > -1 && handlers.splice(index, 1);\n            }\n            else {\n                delete eventMap[type];\n            }\n        },\n        emit(type, event) {\n            const handlers = eventMap[type] || [];\n            return mapItem(handlers, handler => handler(event));\n        }\n    };\n};\n\n// local storage will not fail the operation.\nconst EVENT_SUCCESS_KEY = 'success';\nconst memoryAdapter = () => {\n    let l1Cache = {};\n    const l1CacheEmitter = createEventManager();\n    const adapter = {\n        set(key, value) {\n            l1Cache[key] = value;\n            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: l1Cache });\n        },\n        get: key => {\n            const value = l1Cache[key];\n            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: l1Cache });\n            return value;\n        },\n        remove(key) {\n            deleteAttr(l1Cache, key);\n            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: l1Cache });\n        },\n        clear: () => {\n            l1Cache = {};\n            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: l1Cache });\n        },\n        emitter: l1CacheEmitter\n    };\n    return adapter;\n};\nconst // delay get localStorage by function, and avoid erroring at initialization\nstorage = () => {\n    myAssert(typeof localStorage !== 'undefined', 'l2Cache is not defined.');\n    return localStorage;\n};\nconst localStorageAdapter = () => {\n    const l2CacheEmitter = createEventManager();\n    const adapter = {\n        set: (key, value) => {\n            storage().setItem(key, JSONStringify(value));\n            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: storage() });\n        },\n        get: key => {\n            const data = storage().getItem(key);\n            const value = data ? JSONParse(data) : data;\n            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: storage() });\n            return value;\n        },\n        remove: key => {\n            storage().removeItem(key);\n            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: storage() });\n        },\n        clear: () => {\n            storage().clear();\n            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: storage() });\n        },\n        emitter: l2CacheEmitter\n    };\n    return adapter;\n};\n\nconst SetCls = Set;\nclass MethodSnapshotContainer {\n    constructor(capacity) {\n        /**\n         * method实例快照集合，发送过请求的method实例将会被保存\n         */\n        this.records = {};\n        this.occupy = 0;\n        myAssert(capacity >= 0, 'expected snapshots limit to be >= 0');\n        this.capacity = capacity;\n    }\n    /**\n     * 保存method实例快照\n     * @param methodInstance method实例\n     */\n    save(methodInstance) {\n        const { name } = getConfig(methodInstance);\n        const { records, occupy, capacity } = this;\n        if (name && occupy < capacity) {\n            // 以method的name为key，将method实例保存到快照中\n            const targetSnapshots = (records[name] = records[name] || newInstance(SetCls));\n            targetSnapshots.add(methodInstance);\n            // 统计数量\n            this.occupy += 1;\n        }\n    }\n    /**\n     * 获取Method实例快照，它将根据matcher来筛选出对应的Method实例\n     * @param matcher 匹配的快照名称，可以是字符串或正则表达式、或带过滤函数的对象\n     * @returns 匹配到的Method实例快照数组\n     */\n    match(matcher, matchAll = true) {\n        // 将filter参数统一解构为nameMatcher和matchHandler\n        let nameString;\n        let nameReg;\n        let matchHandler;\n        let nameMatcher = matcher;\n        if (isPlainObject(matcher)) {\n            nameMatcher = matcher.name;\n            matchHandler = matcher.filter;\n        }\n        if (instanceOf(nameMatcher, RegExpCls)) {\n            nameReg = nameMatcher;\n        }\n        else if (isString(nameMatcher)) {\n            nameString = nameMatcher;\n        }\n        const { records } = this;\n        // 通过解构的nameMatcher和filterHandler，获取对应的Method实例快照\n        let matches = newInstance((SetCls));\n        // 如果有提供namespace参数则只在这个namespace中查找，否则在所有缓存数据中查找\n        if (nameString) {\n            matches = records[nameString] || matches;\n        }\n        else if (nameReg) {\n            forEach(filterItem$1(objectKeys(records), methodName => nameReg.test(methodName)), methodName => {\n                records[methodName].forEach(method => matches.add(method));\n            });\n        }\n        const fromMatchesArray = isFn(matchHandler) ? filterItem$1([...matches], matchHandler) : [...matches];\n        return (matchAll ? fromMatchesArray : fromMatchesArray[0]);\n    }\n}\n\nconst typeGet = 'GET';\nconst typeHead = 'HEAD';\nconst typePost = 'POST';\nconst typePut = 'PUT';\nconst typePatch = 'PATCH';\nconst typeDelete = 'DELETE';\nconst typeOptions = 'OPTIONS';\nconst defaultAlovaOptions = {\n    /**\n     * GET请求默认缓存5分钟（300000毫秒），其他请求默认不缓存\n     */\n    cacheFor: {\n        [typeGet]: 300000\n    },\n    /**\n     * 共享请求默认为true\n     */\n    shareRequest: trueValue,\n    /**\n     * method快照数量，默认为1000\n     */\n    snapshots: 1000\n};\nlet idCount = 0;\nclass Alova {\n    constructor(options) {\n        var _a, _b;\n        const instance = this;\n        instance.id = (options.id || (idCount += 1)).toString();\n        // 如果storage未指定，则默认使用localStorage\n        instance.l1Cache = options.l1Cache || memoryAdapter();\n        instance.l2Cache = options.l2Cache || localStorageAdapter();\n        // 合并默认options\n        instance.options = {\n            ...defaultAlovaOptions,\n            ...options\n        };\n        instance.snapshots = newInstance((MethodSnapshotContainer), (_b = (_a = options.snapshots) !== null && _a !== void 0 ? _a : defaultAlovaOptions.snapshots) !== null && _b !== void 0 ? _b : 0);\n    }\n    Get(url, config) {\n        return newInstance((Method), typeGet, this, url, config);\n    }\n    Post(url, data = {}, config) {\n        return newInstance((Method), typePost, this, url, config, data);\n    }\n    Delete(url, data = {}, config) {\n        return newInstance((Method), typeDelete, this, url, config, data);\n    }\n    Put(url, data = {}, config) {\n        return newInstance((Method), typePut, this, url, config, data);\n    }\n    Head(url, config) {\n        return newInstance((Method), typeHead, this, url, config);\n    }\n    Patch(url, data = {}, config) {\n        return newInstance((Method), typePatch, this, url, config, data);\n    }\n    Options(url, config) {\n        return newInstance((Method), typeOptions, this, url, config);\n    }\n}\nlet boundStatesHook = undefinedValue;\nconst usingL1CacheAdapters = [];\nconst usingL2CacheAdapters = [];\n/**\n * create an alova instance.\n * @param options alova configuration.\n * @returns alova instance.\n */\nconst createAlova = (options) => {\n    const alovaInstance = newInstance((Alova), options);\n    const newStatesHook = alovaInstance.options.statesHook;\n    if (boundStatesHook) {\n        myAssert(boundStatesHook === newStatesHook, 'expected to use the same `statesHook`');\n    }\n    boundStatesHook = newStatesHook;\n    const { l1Cache, l2Cache } = alovaInstance;\n    !usingL1CacheAdapters.includes(l1Cache) && pushItem$1(usingL1CacheAdapters, l1Cache);\n    !usingL2CacheAdapters.includes(l2Cache) && pushItem$1(usingL2CacheAdapters, l2Cache);\n    return alovaInstance;\n};\n\nconst promiseStatesHook = () => {\n    myAssert(!!boundStatesHook, `\\`statesHook\\` is not set in alova instance`);\n    return boundStatesHook;\n};\n\nexport { Method, createAlova, globalConfig, globalConfigMap, hitCacheBySource, invalidateCache, promiseStatesHook, queryCache, setCache };\n"],
  "mappings": "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",
  "names": ["newInstance", "key", "sourceKey", "undefStr", "pushItem", "mapItem", "filterItem"]
}
